# 技術レポート: 送信ログ「本日分」判定ロジックの修正とエピソード記憶との整合性確保 (2026-01-04)

## 背景
API送信ログ制限機能において、「本日分のみ」を選択できるオプションがある。これは、エピソード記憶（長期的な文脈）を活用しつつ、直近の会話（短期的な文脈）のみを「生ログ」としてAPIに送信することで、トークン消費を抑えつつ文脈を維持する目的で導入された。

当初の仕様では、「今日のエピソード記憶が作成されていない間（＝当日中）は、昨日のログも含めて送信する」としていたが、実際の挙動として**常に昨日以前のログが含まれてしまう**という問題が発生していた。

## 問題の原因

### 1. エピソード記憶ファイル構造の誤認
修正前のロジックでは、エピソード記憶が「日付ごとの個別JSONファイル（例: `2026-01-04.json`）」として保存されることを前提としていた。そして、「今日のファイルが存在するか」をチェックしていた。

しかし、実際の仕様（`episodic_memory_manager.py`）では、**すべてのエピソード記憶は単一の `episodic_memory.json` ファイルに追記される**構造であった。そのため、「今日のファイル」は永遠に作成されず、常に条件分岐が `False`（昨日も含める）に落ちていた。

### 2. 「今日」の記憶は当日に存在しない
また、エピソード記憶は原則として「過去の日付」に対して生成されるものであるため、**当日のエピソード記憶が存在することは稀**（手動作成などを除く）である。したがって、「今日のエピソード記憶があれば今日以降」という判定条件自体が、意図した挙動（昨日分の記憶化完了判定）と一致していなかった。

### 3. 深夜帯のコンテキスト断絶リスク
日付が変わった直後（例: 00:01）にエピソード記憶が作成されたと仮定すると、チャットログフィルタが「今日以降（0件）」となり、直前の会話文脈が一時的に断絶する問題が潜在していた。

## 解決策

### 1. 判定ロジックの刷新 (`gemini_api.py`)
`_get_effective_today_cutoff` 関数を修正し、以下のロジックを実装した。

1. `episodic_memory.json` をロードする。
2. エントリー内の `date` フィールドを走査する。
3. **「昨日の日付」**のエントリー（単独日付または日付範囲に含まれる）が存在するか確認する。
   - **存在する場合**: 昨日分の記憶化は完了しているとみなし、カットオフ日を「今日」に設定。
   - **存在しない場合**: 昨日分はまだ記憶化されていない（または記憶がない）とみなし、カットオフ日を「昨日」に設定してコンテキストを補完する。

これにより、ファイルベースのエピソード記憶管理仕様と整合するようになった。

### 2. 最低表示・送信数の保証 (`gemini_api.py`, `ui_handlers.py`)
エピソード記憶作成直後のログ消失を防ぐため、**「最低5往復（10メッセージ）」**の表示・送信を保証する安全策を導入した。

- 日付フィルタリング適用後、メッセージ数がこの閾値を下回る場合、フィルタ前の全履歴から直近分を補填して送信する。
- これにより、日付変更線を跨ぐ会話でもスムーズな文脈維持が可能となった。

## 今後の課題

- **パフォーマンス**: 現在は判定のために毎回 `episodic_memory.json` を全ロードしている。ファイルサイズが巨大になった場合、オーバーヘッドになる可能性がある。将来的にはインデックス管理や、最終更新日のキャッシュなどを検討すべきである。
- **UIとの整合性**: 今回の修正はバックエンド（API送信）とフロントエンド（チャット表示）の両方に適用したが、ロジック自体はそれぞれのファイルに記述されている（DRY原則の観点で改善余地あり）。共通ユーティリティ化が望ましい。

## 関連ファイル
- `gemini_api.py`
- `ui_handlers.py`
- `constants.py`
- `episodic_memory_manager.py`
