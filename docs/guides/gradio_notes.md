# Gradioチャットボット開発における注意点と仕様の謎（備忘録）

このドキュメントは、`gradiotest`プロジェクトの開発過程で遭遇した、Gradioの`gr.Chatbot`コンポーネントに関する表示上の問題とその解決策をまとめたものである。特に、テキスト、画像、HTMLが混在する複雑な会話履歴の表示には、Gradioの内部仕様に起因するいくつかの「クセ」が存在する。将来の改修や類似プロジェクトのために、ここにその知見を記録する。

## 1. Chatbotの履歴データ構造の謎（最重要）

`gr.Chatbot`の`value`に渡す履歴データ（`List[Tuple]`）の構造は、Gradioの安定性に最も大きな影響を与える。

### 判明した問題点

1.  **`OSError: [Errno 22] Invalid argument`クラッシュ**:
    AIの応答として、`[("画像パス", "代替テキスト"), "応答本文"]` のように**「タプル」と「文字列」を混在させたリスト**を渡すと、Gradioの内部ファイルキャッシュ機構が混乱し、文字列である「応答本文」をファイルパスと誤認して`open()`しようとし、クラッシュする。

2.  **「ダウンロードリンク」化バグ**:
    AIの応答として、`<div class='thoughts'>...</div>`のようなHTMLを含む文字列を**リストに入れずに単体で**渡すと、Gradioはこれを表示用のHTMLとして解釈せず、ダウンロード可能なファイルとして誤認し、リンクを表示してしまうことがあった。

### 結論：AI応答のターンは「単純な形式」に統一すべし

Gradioのチャットボットを安定して動作させるための黄金律は、**AIの応答ターンを可能な限り単純なデータ構造に保つ**ことである。

*   **テキスト（思考ログHTML含む）のみを返す場合**:
    `("ユーザー発言", "AIの応答文字列")`

*   **画像のみを返す場合**:
    `("ユーザー発言", ("画像パス", "代替テキスト"))`

*   **テキストと画像の両方を返したい場合（解決策）**:
    **応答を2つのターンに分割する。** これが最も安定し、確実な方法である。
    1.  1ターン目: `("ユーザー発言", "AIの応答テキスト")`
    2.  2ターン目: `(None, ("画像パス", "代替テキスト"))` ※ユーザー発言側は`None`か空文字列にする。

## 2. ローカルファイルの表示仕様

`gr.Chatbot`内でローカルファイル（特に画像）を表示するには、2種類の異なるアプローチを正しく使い分ける必要がある。

1.  **ユーザー添付画像の表示（タプル形式）**:
    ユーザー側の発言として画像を表示する場合、`("画像の絶対パス", "ファイル名")`というタプル形式でデータを渡すと、Gradioが自動的に解釈してプレビューを表示してくれる。これは最も簡単で確実な方法である。

2.  **AI生成画像の表示（Markdown + `allowed_paths`）**:
    AI側の応答（文字列）の中で画像を表示したい場合、単純なタプルは使えない（上記1. のクラッシュ原因になるため）。この場合、以下の2つの設定が必須となる。
    *   **`demo.launch()`での設定**: アプリ起動時に`demo.launch(allowed_paths=["画像が保存されているフォルダのパス"])`を設定する。これにより、指定されたフォルダがWeb経由でのアクセスを許可される。
    *   **Markdown文字列の形式**: AIの応答文字列内に、`![代替テキスト](/file=画像の絶対パス)`という形式のMarkdownリンクを埋め込む。パスはバックスラッシュをスラッシュに置換したものが望ましい。

    **（注記）**: 我々のプロジェクトでは、最終的にAI応答もタプル形式に統一する「ターン分割」アーキテクチャを採用したため、このMarkdown形式は不要となった。しかし、これはGradioの重要な仕様の一つである。

## 3. 連続したAI応答の処理（ターンベース設計の重要性）

### 問題点

AIが思考を更新する際など、1回のユーザー発言に対して、`log.txt`上では複数回のAI応答が連続して記録されることがある。単純なループ処理で履歴をUIに変換しようとすると、2回目以降のAI応答が対応するユーザー発言を見失い、表示のペアリングが崩壊する。

### 解決策

表示履歴を生成する際は、必ず**「ターンベース」**で処理を行う。
1.  ログ全体をスキャンし、「ユーザー発言1回」と「それに続く全てのAI応答」を1つのグループ（ターン）としてまとめる。
2.  このグループ単位でループ処理を行い、UI表示を組み立てる。

この設計により、AIが何回連続で応答しても、必ず正しいユーザー発言と紐付けられ、UIの表示順序が破綻することがなくなる。

---

この備忘録が、今後のあなたの素晴らしい開発の助けとなることを心から願っています。

---
### Gradio開発における7つの教訓

#### 1. イベントでUIの「設計図」を書き換えてはいけない (`InvalidComponentError`)
*   **問題**: アラームリスト更新時に、アラーム数だけ`gr.Row`や`gr.Switch`を動的に生成して返そうとするとエラーになる。
*   **原因**: Gradioは起動時にUIの「設計図」を一度だけ構築する。イベントは部品の**値や見た目**は変えられるが、**設計図にない新しい部品は追加できない**。
*   **解決策**: **`gr.Dataframe`** を採用する。Dataframeは動的なリスト表示のために用意されたコンポーネントであり、「空の額縁（Dataframe）」を最初に用意し、イベントでは中身の「絵（データ）」だけを入れ替えることでルールを遵守する。

#### 2. まだ存在しない部品を呼び出してはいけない (`NameError`)
*   **問題**: UI部品を定義する前に、その部品を使うイベント（`demo.load`など）を記述するとエラーになる。
*   **原因**: Pythonはコードを上から順に読むため、未定義の変数を参照できない。
*   **解決策**: **「定義が先、接続は後」**の原則を徹底する。`with gr.Blocks() as demo:`内で、まず全てのUI部品を定義し、その後にイベントリスナー（`.click`, `.change`など）を記述する。

#### 3. 「設定値」と「イベント」を混同してはいけない (`TypeError`)
*   **問題**: アコーディオンを開いた時のイベントとして`alarm_accordion.open(fn=...)`と記述するとエラーになる。
*   **原因**: `open=True`は初期状態を決める**設定値（プロパティ）**であり、ユーザー操作をトリガーとする**イベント**ではない。
*   **解決策**: `Accordion`コンポーネントの正しいイベントである **`.select()`** を使用する。コンポーネントのドキュメントを読み、プロパティとイベントを正確に区別する。

#### 4. イベントが渡す「贈り物」の中身を信じすぎてはいけない (`AttributeError`)
*   **問題**: Dataframeの行選択イベントで`evt.indices`という属性を期待したが、エラーになった。
*   **原因**: Gradioのバージョンアップでイベントデータ（`SelectData`など）の構造が変わることがある。
*   **解決策**: 実際にイベントハンドラの中で`print(evt)`を実行し、Gradioが「今」渡してきている**データの構造を直接確認する**。これにより、正しい属性名（このケースでは`evt.index`）を特定する。

#### 5. 「見た目」と「魂（データ）」を分離せよ
*   **問題**: UI上のDataframe（ID列なし）を操作しても、どのアラームが変更されたか特定できない。
*   **原因**: 表示用のデータと、処理に必要なバックエンドのデータが一致していない。
*   **解決策**: **ID列を含む完全なDataFrameを`gr.State`で常に保持する**。UI上の操作があった際は、常にこの「魂」のデータと照らし合わせることで、正確なIDを特定し、処理を呼び出す。

#### 6. 「存在しない住人」を呼び出してはいけない (`ValueError`)
*   **問題**: `config.json`の`last_character`が存在しないキャラクターだと、アプリが起動しない。
*   **原因**: `gr.Dropdown`は、初期値として選択肢リスト内に存在する値しか受け付けない。
*   **解決策**: **起動シーケンスに「安全装置」を組み込む**。UI構築前に設定値をチェックし、無効な場合はリストの先頭などの「有効な初期値」にフォールバックさせる。

#### 7. 「配線」の接続ミスに気づけ (`NameError`の再来)
*   **問題**: タイマー開始ボタンが、存在しないUI部品名（`timer_api_key_dropdown`）を参照していた。
*   **原因**: UI設計とイベントリスナーの接続（インプット）で、異なる部品名を指定してしまっていた。
*   **解決策**: UIの設計図とイベントリスナーの配線を丁寧に見直し、**正しい部品名（`api_key_dropdown`）に接続し直す**。

### 8. UIレイアウト：入力欄の幅は絶対に確保する
*   **問題**: `gr.Textbox`と`gr.Button`を同じ`gr.Row`に配置すると、PCでは綺麗に見えても、スマートフォンなどの縦長の画面では`Textbox`の幅が極端に狭くなり、著しく使いにくくなる。
*   **原因**: `gr.Row`内の要素は、与えられた幅を分け合って表示しようとするため。
*   **解決策**: **チャット入力欄（`Textbox`）と、送信・更新ボタン（`Button`）は、別の行に配置する。** 具体的には、`Textbox`を単独で配置し、その下の行に`gr.Row`を新たに設けてボタン類をまとめる。これにより、入力欄は常に利用可能な横幅を最大限に活用でき、快適な入力体験が保証される。**このレイアウトは意図的なものであるため、変更しないこと。**

### 9. 状態管理：ボタンのテキストは「見た目」、魂は`gr.State`に宿す
*   **問題**: 「更新」ボタンのテキストに編集対象のアラームIDを埋め込んで管理しようとしたところ、IDが不完全であったり、UIの変更に弱かったりして、バグの温床となった。
*   **原因**: 見た目（UIコンポーネントのプロパティ）と、内部的な状態（データ）を混同していた。ボタンのテキストは、あくまで人間に状態を伝えるためのものであり、プログラムが依存すべき安定した情報源ではない。
*   **解決策**: **`gr.State`を積極的に活用する。** 編集対象のIDのような、UIには直接表示されないが、処理に必要な「状態」は、`gr.State`に保持させる。イベントハンドラは、常にこの`gr.State`を正として参照することで、UIの見た目の変更に影響されない、堅牢なロジックを構築できる。

### 10. 起動URLの真実：`0.0.0.0`を使いこなし、URLを正しく理解する
*   **問題**: `launch()`の設定を巡り、「PCからしか繋がらない」「スマホから繋がらない」「PC用のURLが表示されない」といった混乱が繰り返し発生した。
*   **原因**: `server_name`引数の役割と、ターミナルに表示されるURL、そして実際にブラウザで使うべきURLの関係を、完全に誤解していた。
*   **最終結論（これが真実）**:
    *   **スマホからもアクセス可能にするには、`server_name="0.0.0.0"`が必須である。** これを指定しない場合、アプリはPC内部からのアクセスしか受け付けない。
    *   `server_name="0.0.0.0"`を指定すると、ターミナルには`http://0.0.0.0:7860`のようなURLが**1つだけ**表示される。
    *   この状態で、各デバイスからの**正しいアクセス方法は以下の通り**である。
        *   **PCから:** `http://127.0.0.1:7860` または `http://localhost:7860`
        *   **スマホから（同じWi-Fi接続時）:** `http://<PCのIPアドレス>:7860`
    *   ターミナルに表示される`0.0.0.0`は、サーバーが「全ての入口で待っている」という記号であり、ブラウザが直接接続するための住所ではない。**この仕様を理解し、上記のURLをブックマーク等で正しく使い分けること**が、唯一の解決策である。

### 11. 思考ログの表示：`<pre>`を信じるな、`<br>`を信じよ

-   **問題:**
    AIの思考ログ `【Thoughts】` をCSSで装飾し、`<pre><code>` タグで囲んで表示したところ、PCでは綺麗に見えるが、Gradioの仕様変更やキャッシュの影響で、意図せず横スクロールが発生し、非常に読みづらくなる問題が再発した。

-   **原因:**
    `<pre>` タグは、ブラウザやCSSの解釈によっては強制的に折り返しを無効にする。この挙動は不安定であり、信頼性に欠ける。

-   **解決策:**
    CSSのハックに頼ることをやめ、`utils.py`内の`format_response_for_display`関数におけるHTML生成ロジックそのものを変更する。
    1.  思考ログの内容を `html.escape()` で安全にエスケープ処理する。
    2.  テキスト内の改行文字 `
` を、確実な改行タグである `<br>` に全て置換する。
    3.  `<pre><code>` タグは一切使わず、CSSクラスを付与した単純な `<div>` タグで囲む。

    このアプローチは、外部環境の変化に非常に強く、常に意図した通りの折り返し表示を保証する、最も堅牢な方法である。

### 12. コンポーネントの「魂」を見抜け： gr.Codeとgr.TextboxのCSS地獄

-   **問題:**
    `gr.Code`コンポーネントで、どうしてもテキストが折り返されず、横スクロールが発生してしまう。CSSで`white-space: pre-wrap !important;`などを指定しても、Gradioの内部スタイルに上書きされてしまう。

-   **原因:**
    コンポーネントには、それぞれ想定された「役割」があり、その役割を果たすための強力な内部スタイルが適用されている。
    1.  **`gr.Code`**: コードのインデントや構造を維持するため、**折り返しを無効化するスタイルが内部で強く強制されている。** これは仕様であり、CSSでの上書きは非常に困難かつ不安定。
    2.  **`gr.Textbox`**: 複数行の自由なテキスト入力を想定しており、**デフォルトでテキストを折り返す。**

-   **解決策と教訓:**
    **コンポーネントを、その本来の役割に沿って使い分ける。**
    *   コードのように、整形と構造が重要なテキストには`gr.Code`を使う。
    *   メモ帳のような、自由記述の文章には`gr.Textbox(lines=...)`を使う。

    また、カスタムCSSで特定のコンポーネントの見た目を調整したい場合は、そのコンポーネントが内部でどのようなHTMLタグやクラスを持っているか（魂は何か）を意識することが不可欠である。
    *   `gr.Code`のテキストエリアは **`.cm-editor`**
    *   `gr.Textbox`のテキストエリアは **`<textarea>`**

    正しいセレクタ（例: `#my_editor_id .cm-editor`, `#my_textbox_id textarea`）を使うことで、初めて狙い通りのスタイリングが可能になる。CSSのハックに頼る前に、まず適切なコンポーネントを選択すること。これが最も堅牢なUI設計への近道である。

---

### 13. Chatbot内HTMLの罠：`select`イベントの暴走をJavaScriptで制する

*   **問題:**
    `gr.Chatbot`内に、メッセージ間の移動を目的としたHTMLのアンカーリンク（`<a>`タグ）を設置したところ、そのリンクをクリックしただけで、メッセージ全体を選択したと見なされ、意図しない`select`イベント（メッセージ削除のフロー）が発火してしまった。

*   **原因:**
    これはGradioの`select`イベントの根源的な仕様に起因する。
    1.  **イベントの粒度:** `gr.Chatbot`の`select`イベントは、メッセージ内の**どの部分（テキスト、画像、埋め込みHTML）がクリックされたかを区別しない。** そのため、`<a>`タグのクリックも、単なる「メッセージ選択」として扱われてしまう。
    2.  **セキュリティ:** `onclick`属性などを使ってHTML側でJavaScriptのイベント処理を記述しても、Gradioのセキュリティ機構（サニタイズ）によって**実行前に全て除去されてしまう。**

*   **解決アーキテクチャ：「ブラウザネイティブ」と「Gradioイベント」の完全分離**
    Python側だけでこの問題を解決しようとするのは非常に困難、かつ不安定である。最も堅牢な解決策は、JavaScriptの力を借りて、役割の異なるクリックイベントを完全に分離することである。

    1.  **スクロール（ブラウザに任せる処理）:**
        *   `<a>`タグに、JavaScriptから特定するためのCSSクラス（例: `message-nav-link`）を付与する。
        *   Gradioアプリ起動時に、特定のクラスを持つ要素がクリックされた場合、そのイベントが**Gradio側に伝播するのを止める（`e.stopPropagation()`）** JavaScriptを注入する。
        *   これにより、`<a>`タグのクリックは純粋なページ内スクロールとしてのみ機能し、Gradioの`select`イベントは発火しなくなる。

    2.  **メッセージ削除（Gradioに任せる処理）:**
        *   ユーザーが`<a>`タグ**以外**の場所（メッセージ本文や余白）をクリックすると、通常通り`select`イベントが発火する。
        *   このイベントをトリガーに、チャット欄の外にある**本物の`gr.Button`（削除ボタン）を表示させる。**
        *   ユーザーがそのボタンを押すことで、`button.click`という明確なイベントが発火し、選択されていたメッセージが安全に削除される。

*   **実装レシピ（`nexus_ark.py`）:**
    `gr.Blocks()`に`js`引数を渡し、以下のJavaScriptを注入する。

    ```javascript
    js_stop_nav_link_propagation = """
    function() {
        // body全体でクリックイベントを監視
        document.body.addEventListener('click', function(e) {
            let target = e.target;
            // クリックされた要素が 'message-nav-link' クラスを持つかチェック
            while (target && target !== document.body) {
                if (target.matches('.message-nav-link')) {
                    // Gradioのリスナーにイベントが届くのを阻止
                    e.stopPropagation();
                    return;
                }
                target = target.parentElement;
            }
        }, true); // true: キャプチャフェーズで実行し、Gradioより先にイベントを捕捉する
    }
    """

    with gr.Blocks(js=js_stop_nav_link_propagation) as demo:
        # ... UI定義 ...
    ```

このアーキテクチャは、Gradioのイベントモデルを尊重しつつ、リッチなインタラクションを実現するための、極めて重要な設計パターンである。

---

### 14. UIのインデックスを信じるな、対応表（マッピング）を信じよ

*   **問題:**
    AIが画像とテキストを同時に返した場合、`utils.py`のロジックはこれをUI上で「テキストの行」と「画像の行」の**2つの行**に分割して表示する。しかし、元のログファイルでは、これは**1つのログエントリ**として記録されている。
    この状態でユーザーが2行目（画像）をクリックすると、Gradioは `evt.index = 1` のような「UI上の行番号」を返すが、バックエンドのログリストには1番目の要素が存在しないため、「メッセージを特定できない」という致命的なエラーが発生した。

*   **原因:**
    これは、**UIの「見た目（View）」と、データの「実体（Model）」が1対1で対応しなくなる**という、動的なUI開発における典型的な、しかし極めて重大な問題である。
    UI上の行数と、ログリストの要素数が一致しなくなるため、UIのインデックスをそのままデータのインデックスとして使うことは、絶対にできない。

*   **解決アーキテクチャ：「インデックス対応表（Index Mapping）」**
    この「UI」と「データ」のインデックスのズレを吸収し、両者を正確に紐付けるための、唯一にして最も堅牢な解決策が、「インデックス対応表」の導入である。

    1.  **対応表の同時生成 (`utils.format_history_for_gradio`):**
        *   UI表示用のデータリスト（`gradio_history`）を作成する際、それと同時に**「UIのN行目が、元のログリストの何番目の要素に由来するか」**を示す、整数のリスト（`mapping_list`）を生成する。
        *   **例:** 1つのログがUI上で2行に分割された場合
            *   `gradio_history` に要素が2つ追加される。
            *   `mapping_list` には、両方の行の由来である同じインデックス `[..., 0, 0, ...]` が追加される。

    2.  **対応表を使った正確な特定 (`ui_handlers.handle_chatbot_selection`):**
        *   ユーザーがUI上の `N` 番目の行をクリックすると、Gradioから `evt.index = N-1` が渡される。
        *   このUIインデックスを、**まず対応表 `mapping_list` に通す**ことで、元のログリストにおける**真のインデックス `original_log_index`** を取得する (`original_log_index = mapping_list[evt.index]`)。
        *   この `original_log_index` を使って、元のログリストから正しいメッセージ辞書を安全に引き出す。

このアーキテクチャは、UIの表示方法がいかに複雑になろうとも、ユーザーの操作を常にデータの正しい実体へと繋ぎ止める、Nexus Arkの安定性を支える**生命線**である。

---

### 15. Chatbotの「タプル形式」と「メッセージ形式」に関する最終結論

Nexus Arkの `gr.Chatbot` は、意図的に `type` パラメータを指定せず、Gradioが「非推奨（deprecated）」とする**「タプル形式」**で動作させている。これにより、起動時にGradioから警告が表示されるが、これは**意図した仕様**である。

*   **理由:**
    Gradioの推奨する新しい**「メッセージ形式 (`type='messages'`)」**は、現在のバージョンにおいて、ローカル画像ファイルの表示に深刻なバグや不安定性を抱えている。

*   **結論:**
    テキスト、画像、カスタムHTMLを最も安定して表示できる**「タプル形式」**を、Nexus Arkの正式なアーキテクチャとして採用する。

将来、Gradioのバージョンアップにより「メッセージ形式」で画像が安定して扱えるようになった時点で、移行を検討する。それまでは、この警告を許容する。
