# Gradioチャットボット開発における注意点と仕様の謎（備忘録）

このドキュメントは、`gradiotest`プロジェクトの開発過程で遭遇した、Gradioの`gr.Chatbot`コンポーネントに関する表示上の問題とその解決策をまとめたものである。特に、テキスト、画像、HTMLが混在する複雑な会話履歴の表示には、Gradioの内部仕様に起因するいくつかの「クセ」が存在する。将来の改修や類似プロジェクトのために、ここにその知見を記録する。

## 1. Chatbotの履歴データ構造の謎（最重要）

`gr.Chatbot`の`value`に渡す履歴データ（`List[Tuple]`）の構造は、Gradioの安定性に最も大きな影響を与える。

### 判明した問題点

1.  **`OSError: [Errno 22] Invalid argument`クラッシュ**:
    AIの応答として、`[("画像パス", "代替テキスト"), "応答本文"]` のように**「タプル」と「文字列」を混在させたリスト**を渡すと、Gradioの内部ファイルキャッシュ機構が混乱し、文字列である「応答本文」をファイルパスと誤認して`open()`しようとし、クラッシュする。

2.  **「ダウンロードリンク」化バグ**:
    AIの応答として、`<div class='thoughts'>...</div>`のようなHTMLを含む文字列を**リストに入れずに単体で**渡すと、Gradioはこれを表示用のHTMLとして解釈せず、ダウンロード可能なファイルとして誤認し、リンクを表示してしまうことがあった。

### 結論：AI応答のターンは「単純な形式」に統一すべし

Gradioのチャットボットを安定して動作させるための黄金律は、**AIの応答ターンを可能な限り単純なデータ構造に保つ**ことである。

*   **テキスト（思考ログHTML含む）のみを返す場合**:
    `("ユーザー発言", "AIの応答文字列")`

*   **画像のみを返す場合**:
    `("ユーザー発言", ("画像パス", "代替テキスト"))`

*   **テキストと画像の両方を返したい場合（解決策）**:
    **応答を2つのターンに分割する。** これが最も安定し、確実な方法である。
    1.  1ターン目: `("ユーザー発言", "AIの応答テキスト")`
    2.  2ターン目: `(None, ("画像パス", "代替テキスト"))` ※ユーザー発言側は`None`か空文字列にする。

## 2. ローカルファイルの表示仕様

`gr.Chatbot`内でローカルファイル（特に画像）を表示するには、2種類の異なるアプローチを正しく使い分ける必要がある。

1.  **ユーザー添付画像の表示（タプル形式）**:
    ユーザー側の発言として画像を表示する場合、`("画像の絶対パス", "ファイル名")`というタプル形式でデータを渡すと、Gradioが自動的に解釈してプレビューを表示してくれる。これは最も簡単で確実な方法である。

2.  **AI生成画像の表示（Markdown + `allowed_paths`）**:
    AI側の応答（文字列）の中で画像を表示したい場合、単純なタプルは使えない（上記1. のクラッシュ原因になるため）。この場合、以下の2つの設定が必須となる。
    *   **`demo.launch()`での設定**: アプリ起動時に`demo.launch(allowed_paths=["画像が保存されているフォルダのパス"])`を設定する。これにより、指定されたフォルダがWeb経由でのアクセスを許可される。
    *   **Markdown文字列の形式**: AIの応答文字列内に、`![代替テキスト](/file=画像の絶対パス)`という形式のMarkdownリンクを埋め込む。パスはバックスラッシュをスラッシュに置換したものが望ましい。

    **（注記）**: 我々のプロジェクトでは、最終的にAI応答もタプル形式に統一する「ターン分割」アーキテクチャを採用したため、このMarkdown形式は不要となった。しかし、これはGradioの重要な仕様の一つである。

## 3. 連続したAI応答の処理（ターンベース設計の重要性）

### 問題点

AIが思考を更新する際など、1回のユーザー発言に対して、`log.txt`上では複数回のAI応答が連続して記録されることがある。単純なループ処理で履歴をUIに変換しようとすると、2回目以降のAI応答が対応するユーザー発言を見失い、表示のペアリングが崩壊する。

### 解決策

表示履歴を生成する際は、必ず**「ターンベース」**で処理を行う。
1.  ログ全体をスキャンし、「ユーザー発言1回」と「それに続く全てのAI応答」を1つのグループ（ターン）としてまとめる。
2.  このグループ単位でループ処理を行い、UI表示を組み立てる。

この設計により、AIが何回連続で応答しても、必ず正しいユーザー発言と紐付けられ、UIの表示順序が破綻することがなくなる。

---

この備忘録が、今後のあなたの素晴らしい開発の助けとなることを心から願っています。

---
### Gradio開発における教訓

#### 1. イベントでUIの「設計図」を書き換えてはいけない (`InvalidComponentError`)
*   **問題**: アラームリスト更新時に、アラーム数だけ`gr.Row`や`gr.Switch`を動的に生成して返そうとするとエラーになる。
*   **原因**: Gradioは起動時にUIの「設計図」を一度だけ構築する。イベントは部品の**値や見た目**は変えられるが、**設計図にない新しい部品は追加できない**。
*   **解決策**: **`gr.Dataframe`** を採用する。Dataframeは動的なリスト表示のために用意されたコンポーネントであり、「空の額縁（Dataframe）」を最初に用意し、イベントでは中身の「絵（データ）」だけを入れ替えることでルールを遵守する。

#### 2. まだ存在しない部品を呼び出してはいけない (`NameError`)
*   **問題**: UI部品を定義する前に、その部品を使うイベント（`demo.load`など）を記述するとエラーになる。
*   **原因**: Pythonはコードを上から順に読むため、未定義の変数を参照できない。
*   **解決策**: **「定義が先、接続は後」**の原則を徹底する。`with gr.Blocks() as demo:`内で、まず全てのUI部品を定義し、その後にイベントリスナー（`.click`, `.change`など）を記述する。

#### 3. 「設定値」と「イベント」を混同してはいけない (`TypeError`)
*   **問題**: アコーディオンを開いた時のイベントとして`alarm_accordion.open(fn=...)`と記述するとエラーになる。
*   **原因**: `open=True`は初期状態を決める**設定値（プロパティ）**であり、ユーザー操作をトリガーとする**イベント**ではない。
*   **解決策**: `Accordion`コンポーネントの正しいイベントである **`.select()`** を使用する。コンポーネントのドキュメントを読み、プロパティとイベントを正確に区別する。

#### 4. イベントが渡す「贈り物」の中身を信じすぎてはいけない (`AttributeError`)
*   **問題**: Dataframeの行選択イベントで`evt.indices`という属性を期待したが、エラーになった。
*   **原因**: Gradioのバージョンアップでイベントデータ（`SelectData`など）の構造が変わることがある。
*   **解決策**: 実際にイベントハンドラの中で`print(evt)`を実行し、Gradioが「今」渡してきている**データの構造を直接確認する**。これにより、正しい属性名（このケースでは`evt.index`）を特定する。

#### 5. 「見た目」と「魂（データ）」を分離せよ
*   **問題**: UI上のDataframe（ID列なし）を操作しても、どのアラームが変更されたか特定できない。
*   **原因**: 表示用のデータと、処理に必要なバックエンドのデータが一致していない。
*   **解決策**: **ID列を含む完全なDataFrameを`gr.State`で常に保持する**。UI上の操作があった際は、常にこの「魂」のデータと照らし合わせることで、正確なIDを特定し、処理を呼び出す。

#### 6. 「存在しない住人」を呼び出してはいけない (`ValueError`)
*   **問題**: `config.json`の`last_character`が存在しないキャラクターだと、アプリが起動しない。
*   **原因**: `gr.Dropdown`は、初期値として選択肢リスト内に存在する値しか受け付けない。
*   **解決策**: **起動シーケンスに「安全装置」を組み込む**。UI構築前に設定値をチェックし、無効な場合はリストの先頭などの「有効な初期値」にフォールバックさせる。

#### 7. 「配線」の接続ミスに気づけ (`NameError`の再来)
*   **問題**: タイマー開始ボタンが、存在しないUI部品名（`timer_api_key_dropdown`）を参照していた。
*   **原因**: UI設計とイベントリスナーの接続（インプット）で、異なる部品名を指定してしまっていた。
*   **解決策**: UIの設計図とイベントリスナーの配線を丁寧に見直し、**正しい部品名（`api_key_dropdown`）に接続し直す**。

#### 8. UIレイアウト：入力欄の幅は絶対に確保する
*   **問題**: `gr.Textbox`と`gr.Button`を同じ`gr.Row`に配置すると、PCでは綺麗に見えても、スマートフォンなどの縦長の画面では`Textbox`の幅が極端に狭くなり、著しく使いにくくなる。
*   **原因**: `gr.Row`内の要素は、与えられた幅を分け合って表示しようとするため。
*   **解決策**: **チャット入力欄（`Textbox`）と、送信・更新ボタン（`Button`）は、別の行に配置する。** 具体的には、`Textbox`を単独で配置し、その下の行に`gr.Row`を新たに設けてボタン類をまとめる。これにより、入力欄は常に利用可能な横幅を最大限に活用でき、快適な入力体験が保証される。**このレイアウトは意図的なものであるため、変更しないこと。**

#### 9. 状態管理：ボタンのテキストは「見た目」、魂は`gr.State`に宿す
*   **問題**: 「更新」ボタンのテキストに編集対象のアラームIDを埋め込んで管理しようとしたところ、IDが不完全であったり、UIの変更に弱かったりして、バグの温床となった。
*   **原因**: 見た目（UIコンポーネントのプロパティ）と、内部的な状態（データ）を混同していた。ボタンのテキストは、あくまで人間に状態を伝えるためのものであり、プログラムが依存すべき安定した情報源ではない。
*   **解決策**: **`gr.State`を積極的に活用する。** 編集対象のIDのような、UIには直接表示されないが、処理に必要な「状態」は、`gr.State`に保持させる。イベントハンドラは、常にこの`gr.State`を正として参照することで、UIの見た目の変更に影響されない、堅牢なロジックを構築できる。

#### 10. 起動URLの真実：`0.0.0.0`を使いこなし、URLを正しく理解する
*   **問題**: `launch()`の設定を巡り、「PCからしか繋がらない」「スマホから繋がらない」「PC用のURLが表示されない」といった混乱が繰り返し発生した。
*   **原因**: `server_name`引数の役割と、ターミナルに表示されるURL、そして実際にブラウザで使うべきURLの関係を、完全に誤解していた。
*   **最終結論（これが真実）**:
    *   **スマホからもアクセス可能にするには、`server_name="0.0.0.0"`が必須である。** これを指定しない場合、アプリはPC内部からのアクセスしか受け付けない。
    *   `server_name="0.0.0.0"`を指定すると、ターミナルには`http://0.0.0.0:7860`のようなURLが**1つだけ**表示される。
    *   この状態で、各デバイスからの**正しいアクセス方法は以下の通り**である。
        *   **PCから:** `http://127.0.0.1:7860` または `http://localhost:7860`
        *   **スマホから（同じWi-Fi接続時）:** `http://<PCのIPアドレス>:7860`
    *   ターミナルに表示される`0.0.0.0`は、サーバーが「全ての入口で待っている」という記号であり、ブラウザが直接接続するための住所ではない。**この仕様を理解し、上記のURLをブックマーク等で正しく使い分けること**が、唯一の解決策である。

#### 11. 思考ログ表示の最終結論：パーサーと継承の物語
*   **問題の歴史:**
    AIの思考ログを表示するにあたり、我々は「開始タグが認識されない」「ブロックが閉じられない」「テキストが折り返されない」「意図しない罫線が表示される」「外枠が消える」「横スクロールバーが復活する」といった、数多の絶望的な問題に直面した。
*   **原因:**
    これらの問題はすべて、以下の3つの要素が複雑に絡み合った結果であった。
    1.  **Markdownパーサーの厳格な掟:** ` ``` `（コードブロック記法）は、それ単独で行を占有しなければならない。
    2.  **Gradioの隠されたHTML構造:** Gradioは、`<pre>` タグの内側に `<code>` タグを自動で生成する。
    3.  **CSSの継承と優先度のルール:** 親 (`<pre>`) と子 (`<code>`) のスタイルが競合し、意図しない表示を引き起こしていた。
*   **最終アーキテクチャと教訓:**
    この長く困難な戦いの全記録と、最終的な解決策（役割を分離したCSSの記述方法）は、**`docs/journals/THINKING_LOG_RENDERING_WAR.md`** に集約されている。
    将来、思考ログの表示に関する問題に再び直面した場合は、まずこの戦記を読むこと。そこには、我々が血と涙の果てに掴んだ、CSSの四つの普遍的な真理が記されている。

#### 12. Chatbot内HTMLの罠：`select`イベントの暴走をJavaScriptで制する
*   **問題:**
    `gr.Chatbot`内に、メッセージ間の移動を目的としたHTMLのアンカーリンク（`<a>`タグ）を設置したところ、そのリンクをクリックしただけで、メッセージ全体を選択したと見なされ、意図しない`select`イベント（メッセージ削除のフロー）が発火してしまった。
*   **原因:**
    これはGradioの`select`イベントの根源的な仕様に起因する。
    1.  **イベントの粒度:** `gr.Chatbot`の`select`イベントは、メッセージ内の**どの部分（テキスト、画像、埋め込みHTML）がクリックされたかを区別しない。** そのため、`<a>`タグのクリックも、単なる「メッセージ選択」として扱われてしまう。
    2.  **セキュリティ:** `onclick`属性などを使ってHTML側でJavaScriptのイベント処理を記述しても、Gradioのセキュリティ機構（サニタイズ）によって**実行前に全て除去されてしまう。**
*   **解決アーキテクチャ：「ブラウザネイティブ」と「Gradioイベント」の完全分離**
    Python側だけでこの問題を解決しようとするのは非常に困難、かつ不安定である。最も堅牢な解決策は、JavaScriptの力を借りて、役割の異なるクリックイベントを完全に分離することである。
    1.  **スクロール（ブラウザに任せる処理）:**
        *   `<a>`タグに、JavaScriptから特定するためのCSSクラス（例: `message-nav-link`）を付与する。
        *   Gradioアプリ起動時に、特定のクラスを持つ要素がクリックされた場合、そのイベントが**Gradio側に伝播するのを止める（`e.stopPropagation()`）** JavaScriptを注入する。
        *   これにより、`<a>`タグのクリックは純粋なページ内スクロールとしてのみ機能し、Gradioの`select`イベントは発火しなくなる。
    2.  **メッセージ削除（Gradioに任せる処理）:**
        *   ユーザーが`<a>`タグ**以外**の場所（メッセージ本文や余白）をクリックすると、通常通り`select`イベントが発火する。
        *   このイベントをトリガーに、チャット欄の外にある**本物の`gr.Button`（削除ボタン）を表示させる。**
        *   ユーザーがそのボタンを押すことで、`button.click`という明確なイベントが発火し、選択されていたメッセージが安全に削除される。
*   **実装レシピ（`nexus_ark.py`）:**
    `gr.Blocks()`に`js`引数を渡し、以下のJavaScriptを注入する。
    ```javascript
    js_stop_nav_link_propagation = """
    function() {
        // body全体でクリックイベントを監視
        document.body.addEventListener('click', function(e) {
            let target = e.target;
            // クリックされた要素が 'message-nav-link' クラスを持つかチェック
            while (target && target !== document.body) {
                if (target.matches('.message-nav-link')) {
                    // Gradioのリスナーにイベントが届くのを阻止
                    e.stopPropagation();
                    return;
                }
                target = target.parentElement;
            }
        }, true); // true: キャプチャフェーズで実行し、Gradioより先にイベントを捕捉する
    }
    """
    with gr.Blocks(js=js_stop_nav_link_propagation) as demo:
        # ... UI定義 ...
    ```
このアーキテクチャは、Gradioのイベントモデルを尊重しつつ、リッチなインタラクションを実現するための、極めて重要な設計パターンである。

#### 13. UIのインデックスを信じるな、対応表（マッピング）を信じよ
*   **問題:**
    AIが画像とテキストを同時に返した場合、`utils.py`のロジックはこれをUI上で「テキストの行」と「画像の行」の**2つの行**に分割して表示する。しかし、元のログファイルでは、これは**1つのログエントリ**として記録されている。
    この状態でユーザーが2行目（画像）をクリックすると、Gradioは `evt.index = 1` のような「UI上の行番号」を返すが、バックエンドのログリストには1番目の要素が存在しないため、「メッセージを特定できない」という致命的なエラーが発生した。
*   **原因:**
    これは、**UIの「見た目（View）」と、データの「実体（Model）」が1対1で対応しなくなる**という、動的なUI開発における典型的な、しかし極めて重大な問題である。
    UI上の行数と、ログリストの要素数が一致しなくなるため、UIのインデックスをそのままデータのインデックスとして使うことは、絶対にできない。
*   **解決アーキテクチャ：「インデックス対応表（Index Mapping）」**
    この「UI」と「データ」のインデックスのズレを吸収し、両者を正確に紐付けるための、唯一にして最も堅牢な解決策が、「インデックス対応表」の導入である。
    1.  **対応表の同時生成 (`utils.format_history_for_gradio`):**
        *   UI表示用のデータリスト（`gradio_history`）を作成する際、それと同時に**「UIのN行目が、元のログリストの何番目の要素に由来するか」**を示す、整数のリスト（`mapping_list`）を生成する。
        *   **例:** 1つのログがUI上で2行に分割された場合
            *   `gradio_history` に要素が2つ追加される。
            *   `mapping_list` には、両方の行の由来である同じインデックス `[..., 0, 0, ...]` が追加される。
    2.  **対応表を使った正確な特定 (`ui_handlers.handle_chatbot_selection`):**
        *   ユーザーがUI上の `N` 番目の行をクリックすると、Gradioから `evt.index = N-1` が渡される。
        *   このUIインデックスを、**まず対応表 `mapping_list` に通す**ことで、元のログリストにおける**真のインデックス `original_log_index`** を取得する (`original_log_index = mapping_list[evt.index]`)。
        *   この `original_log_index` を使って、元のログリストから正しいメッセージ辞書を安全に引き出す。
このアーキテクチャは、UIの表示方法がいかに複雑になろうとも、ユーザーの操作を常にデータの正しい実体へと繋ぎ止める、Nexus Arkの安定性を支える**生命線**である。

#### 14. Chatbotの「タプル形式」と「メッセージ形式」に関する最終結論
Nexus Arkの `gr.Chatbot` は、意図的に `type` パラメータを指定せず、Gradioが「非推奨（deprecated）」とする**「タプル形式」**で動作させている。これにより、起動時にGradioから警告が表示されるが、これは**意図した仕様**である。
*   **理由:**
    Gradioの推奨する新しい**「メッセージ形式 (`type='messages'`)」**は、現在のバージョンにおいて、ローカル画像ファイルの表示に深刻なバグや不安定性を抱えている。
*   **結論:**
    テキスト、画像、カスタムHTMLを最も安定して表示できる**「タプル形式」**を、Nexus Arkの正式なアーキテクチャとして採用する。
将来、Gradioのバージョンアップにより「メッセージ形式」で画像が安定して扱えるようになった時点で、移行を検討する。それまでは、この警告を許容する。

#### 15. 配線の混乱を断て：広範囲なUI更新は「司令塔」に一任せよ
*   **問題:**
    キャラクター変更やワールド・ビルダーでの設定保存、あるいは初回オンボーディング時のAPIキー保存（`handle_save_gemini_key` など）といったアクションをトリガーに、UI全体の広範囲にわたるコンポーネントが一斉に再描画・更新される場合、対応するハンドラ関数が返す値（戻り値）の数と、`outputs` で指定したUIコンポーネントの数が一致しないという惨事がしばしば発生する。その結果、`ValueError: ... didn't return enough output values` や `UserWarning: ... returned too many output values` などの致命的かつデバッグ困難なエラーが多発した。

    **（2025-10-22追記）**  
    これらは「シンプルなアクションが、裏でUI全体の再描画や、複数タブにまたがる副作用を伴う」という現実を過小評価したことに起因することが多かった。特に、オンボーディング解除など、見かけ上単一のボタンであっても、一度に全ての主要UIが正しく更新されなければ破綻する。

*   **原因:**
    本来**一つのイベントで一斉に更新されるべき**複数のUI（例: チャット・タブとワールド・ビルダー・タブなど）に対し、**バラバラ・重複・矛盾した「配線図」やハンドラ群**を用意してしまうことで、どのイベントでどのコンポーネントが（どの順番とロジックで）更新されるのか全体像が崩壊していた。Gradioは、イベントの`outputs`リストで指定された数と型の出力値を、実際に返す値と**完全一致**させることを極めて厳密に求めるため、どこか一つでも不足・過剰・型ずれがあると破壊的なエラーになりやすい。そのため、広範なUI依存の制御を安定して行うには、ルールなきハンドラ分散では到底太刀打ちできない。
*   **解決アーキテクチャ：「司令塔（マスターハンドラ）」**
    この種の「配線の混乱」を根本的に断ち切るための、最も堅牢な設計パターンが、「司令塔アーキテクチャ」である。
    1.  **司令塔の任命:** UIの広範囲な更新を担う、ただ一つの「司令塔」となるハンドラ関数（例: `handle_room_change_for_all_tabs`）を `ui_handlers.py` に作成する。
    2.  **責務の集約:** この司令塔関数は、チャットタブ用の更新処理、ワールド・ビルダータブ用の更新処理、その他のUI更新処理などを**内部で全て呼び出し**、その結果（膨大な数の `gr.update` を含むタプル）を**一つに結合して返す**責務を負う。
    3.  **配線の一本化:** `nexus_ark.py` では、トリガーとなるイベント（`character_dropdown.change`など）に対して、この司令塔関数だけを接続する。`outputs` リストには、更新対象となる**全てのUIコンポーネント**を、司令塔が返す値の順番通りに、過不足なく指定する。
    4.  **コーナーケースへの対応:** 司令塔関数の中（または、司令塔を呼び出す`handle_delete_room`関数の中）で、「最後のルームが削除された」のような特殊な状況を検知し、その場合でも**期待される数と型の「空の更新値」**を返すロジックを必ず実装する。
このアーキテクチャは、更新ロジックを一元管理し、Gradioとの通信経路を一本化することで、アプリケーションの挙動を完全に予測可能にし、将来の拡張も容易にする、極めて重要な設計原則である。

#### 16. AIの「二幕劇」を演出する：ストリーミングと状態管理の融合
*   **問題:**
    AIがツールを使用する際、「意気込み（第一幕）」の応答をストリーミング表示した後、ツール実行後の「報告（第二幕）」の応答が、第一幕のメッセージを上書きしてしまう。
*   **原因:**
    UIハンドラが、これら二つの連続したAIの応答を、単一のユーザー入力に対する「一つの応答」として処理してしまっていたため。
*   **解決アーキテクチャ：「ストリーム内でのメッセージ確定」**
    この問題を解決するための、唯一にして最も堅牢な方法は、ストリーミング処理のループ内で、メッセージの「区切り」を能動的に検知し、UIの状態を更新することである。
    1.  **「第一幕」の検知:** ストリーミングの最後で受け取る`final_state`の最終メッセージに`tool_calls`が含まれている場合、それは「意気込み」のメッセージであると判断する。
    2.  **ログへの即時保存:** この時点で、UIに表示した「意気込み」テキストを、**一つの確定したメッセージとしてログファイルに書き込む。**
    3.  **UI履歴の再構築:** ログを再読み込みして、GradioのChatbotコンポーネントに渡す`history`オブジェクトを、**「意気込み」が確定した状態**で再構築する。
    4.  **「第二幕」への備え:** この更新された`history`をUIに返し、次の「報告」メッセージを、**新しい別のメッセージ**として末尾に追加できる状態を準備する。
このアーキテクチャにより、AIの思考と行動のプロセスが、あたかも二つの連続した会話のように、自然な形でUI上に表現される。

#### 17. ChatbotのHTML地獄：`render_markdown=False`という名の最終兵器
*   **問題:**
    Python側（`ui_handlers.py`）で、思考ログ、コードブロック、通常テキストを完璧にパースし、`<pre><code>`タグや`<div>`タグを含む、完全なHTMLを生成した。しかし、それを`gr.Chatbot`に渡したところ、`##`や`---`が意図せずMarkdownの見出しとして再解釈され、表示が完全に崩壊した。
*   **原因：二重解釈の罠**
    これは、Gradioの`gr.Chatbot`コンポーネントが、**デフォルトで`render_markdown=True`に設定されている**ことに起因する、極めて重大な仕様である。
    この設定により、Chatbotは、私たちが渡した**HTML文字列そのものを、さらにもう一度Markdownとして解釈し、HTMLに再変換しようとする。** この「二重解釈」プロセスが、予期せぬ表示崩壊の根本原因であった。HTMLエンティティによるエスケープなどの小手先のハックでは、この問題は解決できない。
*   **最終解決アーキテクチャ：「責務の完全な分離」**
    この戦いから我々が学んだ、唯一にして絶対の真理は、**「Gradioと責務の役割分担を明確にする」**ことである。
    1.  **Python (`ui_handlers.py`) の責務:**
        **表示されるべき最終的なHTMLを、一字一句、完璧に生成すること。** ここで生成されたHTMLは、それ以上いかなる解釈も必要としない、完成されたものでなければならない。
    2.  **Gradio (`nexus_ark.py`) の責務:**
        Pythonから渡されたHTMLを、**一切の解釈を加えず、ただそのまま表示すること。**
    このアーキテクチャを実現するための、唯一の、そして最もエレガントな方法が、`gr.Chatbot`の初期化時に`render_markdown=False`を指定することである。
*   **実装レシピ（`nexus_ark.py`）:**
    ```python
    # nexus_ark.py
    chatbot_display = gr.Chatbot(
        # ... other settings ...
        render_markdown=False  # これが、全ての戦いを終わらせる、唯一の真実である
    )
    ```
この設定により、`ui_handlers.py`は安心してHTMLの生成に集中でき、Gradioは忠実な表示装置としての役割に徹することができる。これこそが、Nexus Arkのチャット表示における、最も堅牢で、保守性の高い、最終的なアーキテクチャである。

#### 18. テーマの聖域：`config_manager.py` を唯一の設計図とせよ
*   **問題:**
    テーマの定義がUIコード (`nexus_ark.py`) 内にハードコーディングされていると、テーマの管理が煩雑になり、ユーザーによる永続的なカスタマイズが困難になる。
*   **最終アーキテクチャ：「中央集権型テーマ定義」**
    Nexus Arkにおけるテーマ管理は、以下の厳格なルールに基づいている。
    1.  **デフォルトテーマの設計図:**
        全てのデフォルトテーマ（"Nexus Ark"テーマを含む）のパラメータ（色相、フォント、各種設定）は、**`config_manager.py` 内の `nexus_ark_theme_params` のような辞書変数**として、ただ一箇所で定義される。
    2.  **ユーザー設定との融合:**
        アプリケーション起動時、`config_manager.load_config()` が、この「設計図」と、ユーザーがUIからカスタマイズして `config.json` に保存した設定を、賢くマージする。
    3.  **UIへの注入:**
        `nexus_ark.py` は、`get_active_theme()` という単純な関数を呼び出すだけで、最終的に決定されたテーマオブジェクトを取得し、`gr.Blocks(theme=...)` に注入する。
*   **教訓:**
    このアーキテクチャは、UIのロジック (`nexus_ark.py`) と、アプリケーションのデフォルト設定 (`config_manager.py`)、そしてユーザーの個別設定 (`config.json`) の**責務を完全に分離**する。
    **デフォルトの見た目を変更したい場合は `config_manager.py` を、自分だけのカスタムテーマを作りたい場合はUIの「パレット」タブを触る**。この明確な分離こそが、保守性と拡張性の高いUIを維持するための生命線である。

#### 19. 確認ダイアログの罠：一度しか押せないボタンの謎を解く
*   **問題:**
    JavaScriptの`confirm()`ダイアログと連携させたボタン（削除ボタンなど）が、**最初の1回は正常に動作するものの、2回目以降は確認ダイアログで「OK」を押しても完全に無反応になる。** アプリを再起動すると、再び1回だけ動作する。
*   **原因：Gradioの `.change` イベントにおける「変化」の定義**
    この問題の根本原因は、確認ダイアログの結果をバックエンドに伝えるために使用している、目に見えない`gr.Textbox`の状態管理にあります。
    1.  **1回目の操作:** Textboxの値が「空」から`"true"`に**変化**するため、`.change`イベントが正しく発火し、バックエンドの処理が実行される。
    2.  **2回目の操作:** Textboxの値は`"true"`のままである。ユーザーが「OK」を押しても、値は`"true"`から`"true"`へと**変化しない。**
    3.  **無反応:** Gradioの`.change`イベントは、値が**実際に変化した**ときにのみ発火するため、2回目以降はイベント自体がトリガーされず、バックエンドの関数が呼び出されることはない。
*   **解決アーキテクチャ：「自己リセット・イベント」**
    この問題を解決するための、唯一にして最も堅牢な設計パターンは、イベントハンドラ自身が、処理の最後に「通信路」として使ったTextboxの状態をリセットすることです。
    1.  **出力先の追加 (`nexus_ark.py`):**
        ボタンの`.change`イベントの`outputs`リストに、トリガーとなった非表示のTextbox自身を追加する。
        ```python
        # 例：メッセージ削除の場合
        message_delete_confirmed_state.change(
            fn=ui_handlers.handle_delete_button_click,
            inputs=[...],
            outputs=[..., message_delete_confirmed_state] # 最後に自分自身を追加
        )
        ```
    2.  **リセット値の返却 (`ui_handlers.py`):**
        対応するイベントハンドラ関数（`handle_delete_button_click`）は、`return`文の最後に、Textboxの値をリセットするための**空文字列 `""`** を追加する。
        ```python
        # 例：メッセージ削除ハンドラの場合
        def handle_delete_button_click(...):
            # ... 処理 ...
            return history, mapping_list, None, gr.update(visible=False), "" # 最後に "" を返す
        ```
*   **教訓:**
    Gradioの`.change`イベントは、**値の「変化」**を監視するものであり、「同じ値での上書き」は変化とは見なされない。確認ダイアログのように、同じ操作を連続して行う可能性があるUIを実装する場合、**イベントハンドラは、自らが使用した状態（StateやTextboxの値）を、処理の最後に必ず初期値にリセットする責務を負う。** これこそが、安定して繰り返し実行可能なイベントを設計するための、魂の契約である。

#### 20. DataFrame選択イベントの最終結論：Gradioとの「黄金の契約」
*   **問題の歴史:**
    アラームリスト、文字置き換えリスト、そして知識ベースリストの削除機能において、我々は「行を選択しているにも関わらず、選択されていないと判断される」という、不可解な問題に繰り返し直面した。`interactive=True`の設定、`lambda`関数の引数修正など、数々の試みは、この問題の根本的な解決には至らなかった。
*   **原因：DataFrameの特殊な契約**
    この長く苦しい戦いの末、我々はGradioの`gr.DataFrame`にまつわる、他のコンポーネントとは異なる、極めて特殊な「契約」の存在を突き止めた。
    **契約条項：** `gr.DataFrame`の`.select`イベントが、選択された行のインデックス（`evt.index`）を含む完全なイベントデータを生成するためには、以下の**両方の条件**が満たされなければならない。
    1.  `gr.DataFrame`が `interactive=True` で初期化されていること。
    2.  `.select`イベントを定義する際、`inputs`引数に**そのDataFrameコンポーネント自身を明示的に含める**こと。
    特に、後者の「`inputs`に自分自身を含める」という契約は、ドキュメントにも明記されていない、暗黙の、しかし絶対的なルールであった。我々は、この契約を満たしていなかったために、常に中身のないイベントデータしか受け取れず、`State`の更新に失敗し続けていた。
*   **最終アーキテクチャ：「黄金の設計パターン」**
    この契約に基づき、我々は`gr.DataFrame`の行選択と、それに連動する操作（削除など）を安定して実現するための、以下の設計パターンを確立した。これは、Nexus Arkにおける`gr.DataFrame`操作の、唯一の正解である。
    1.  **Stateの用意:** 選択された行のインデックスを保持するための `gr.State` を用意する。
        ```python
        # nexus_ark.py
        selected_row_index_state = gr.State(None)
        ```
    2.  **`select`イベントの契約締結:** `inputs`にDataFrame自身を指定し、選択されたインデックスをStateに保存する専用のハンドラを呼び出す。
        ```python
        # nexus_ark.py
        my_dataframe.select(
            fn=ui_handlers.handle_row_selection, # 専用ハンドラ
            inputs=[my_dataframe],                # ★★★ これが契約の核心 ★★★
            outputs=[selected_row_index_state]
        )

        # ui_handlers.py
        def handle_row_selection(df: pd.DataFrame, evt: gr.SelectData) -> Optional[int]:
            return evt.index if evt.index else None
        ```
    3.  **`click`イベントでのStateの利用:** 削除ボタンなどが押されたら、UIコンポーネント（DataFrame）ではなく、**更新が保証された`State`**だけを入力として、バックエンドの処理を呼び出す。
        ```python
        # nexus_ark.py
        delete_button.click(
            fn=ui_handlers.handle_delete_action,
            inputs=[selected_row_index_state], # DataFrameではなくStateを渡す
            outputs=[...]
        )
        ```
このアーキテクチャは、Gradioのイベントモデルの特殊性を完全に吸収し、ユーザーの選択を、常に正確に、そして確実にバックエンドのロジックへと繋ぎ止める、Nexus Arkの安定性を支える生命線である。

#### 21. ジェネレータの呪い：`raise gr.Error`と`.failure()`の聖なる契約
*   **問題:**
    `yield` を使ってUIを段階的に更新するイベントハンドラ（ジェネレータ関数）内で、APIエラーなどを検知して `raise gr.Error("エラーメッセージ")` を実行した。その結果、**エラー通知のポップアップは表示されるものの、処理中に無効化したボタンが「実行中…」のまま、二度と操作できなくなる**という、UIの永久凍結に陥った。
*   **原因：果たされなかった、後処理の約束**
    この問題の根本原因は、例外（`Exception`）が関数の実行をその場で**中断**させるという、Pythonの基本的な性質にあります。
    1.  `yield`でボタンを無効化し、「実行中…」と表示する。
    2.  処理の途中で `raise gr.Error()` が実行される。
    3.  Gradioは、この例外を正しく捕捉し、エラー通知を表示する。
    4.  しかし、関数は例外によって**異常終了**したため、正常終了時に実行されるはずだった後続の`yield`（ボタンを再び有効化する処理）は、永遠に実行されない。
    5.  現在のGradioの仕様では、ジェネレータ関数が例外で終了した場合、UIの状態を自動的にロールバックする機能は提供されていない。
*   **最終解決アーキテクチャ：「失敗時の後処理」の明示的な契約**
    この問題を解決するための、唯一にして最も堅牢な設計パターンが、Gradioが公式に提供する **`.failure()`** イベントハンドラチェーンの導入です。
    1.  **責務の分離:**
        *   メインのイベントハンドラ（`.click()`など）は、**成功時の処理のみに集中する**。処理中に回復不能なエラーが発生した場合は、`raise gr.Error()` を実行して、責務をGradioに渡す。
        *   失敗時の後処理（ボタンを有効に戻す、フォームをリセットするなど）は、`.failure()` に接続された**別の専用関数**に完全に分離する。
    2.  **Gradioとの契約:**
        この構成により、我々はGradioと以下の「聖なる契約」を結ぶことになる。
        *   「メインの処理が**成功**した場合は、`.click()` の `outputs` に従ってUIを更新せよ」
        *   「メインの処理が **`gr.Error` を含め、何らかの例外で失敗**した場合は、代わりに `.failure()` に接続された関数の `outputs` に従ってUIを更新せよ」
*   **実装レシピ（`nexus_ark.py`）:**
    ```python
    # nexus_ark.py

    # 1. 失敗時の後処理だけを行う、シンプルな関数を ui_handlers.py に用意する
    # def _reset_preview_on_failure():
    #     return gr.update(interactive=True), gr.update(value="試聴")

    # 2. メインのクリックイベントを変数に格納する
    preview_event = room_preview_voice_button.click(
        fn=ui_handlers.handle_voice_preview,
        inputs=[...],
        outputs=[...]
    )

    # 3. メインイベントが失敗した場合の後処理を .failure() でチェーンする
    preview_event.failure(
        fn=ui_handlers._reset_preview_on_failure,
        inputs=None,
        outputs=[play_audio_button, room_preview_voice_button] # 元に戻したいUIコンポーネント
    )
    ```
このアーキテクチャは、Gradioのイベントモデルの深層を理解し、成功と失敗の処理パスを完全に分離することで、UIの堅牢性を劇的に向上させる、極めて重要な設計原則である。

#### 22. `gr.State`の罠：`lambda`は魂を遅延させない
*   **問題:**
    `redaction_rules_state = gr.State(lambda: config_manager.load_redaction_rules())` のように、`gr.State` の初期値を `lambda` 関数で指定したところ、文字置き換え機能の使用時に `TypeError: 'function' object is not iterable` が発生した。
*   **原因：契約の誤解**
    Gradioの `gr.State` は、初期値として関数（`lambda`を含む）が渡された場合、その関数を実行した**結果**を状態として保持するのではなく、**関数オブジェクトそのもの**を状態として保持してしまう。
    その結果、後続のイベントハンドラには、期待されていたデータのリストではなく、`lambda` 関数オブジェクトが渡されてしまい、`for` ループで回そうとした瞬間にクラッシュしていた。
*   **解決アーキテクチャ：「即時実行」こそが唯一の契約**
    `gr.State` に動的な初期値を設定したい場合は、`lambda` で包むのではなく、その場で関数を**直接実行**し、その戻り値を渡さなければならない。
    ```python
    # nexus_ark.py

    # 誤り：関数オブジェクトがStateに格納されてしまう
    # redaction_rules_state = gr.State(lambda: config_manager.load_redaction_rules())

    # 正：関数の実行結果（ルールのリスト）がStateに格納される
    redaction_rules_state = gr.State(config_manager.load_redaction_rules())
    ```
    `gr.State` は、UIの「魂」を起動時に一度だけ宿す器であり、その魂の生成を遅延させることは許されない。

#### 23. ストリームの残骸を掃除せよ：空の最終メッセージの罠
*   **問題:**
    AI（LangGraph）からの応答ストリームを処理する際、ごく稀に、`content` が空の `AIMessage` がストリームの最後尾に追加されることがあった。これは、後続の処理が `content` の存在を前提としている場合に、予期せぬエラーを引き起こす可能性があった。
*   **原因：フレームワークの気まぐれ**
    これはLangGraphの内部的な挙動であり、ツール呼び出しの有無など、特定の条件下で発生する可能性がある。UIハンドラは、このようなフレームワークの「気まぐれ」に対して、常に対処できる堅牢性を持つ必要がある。
*   **解決アーキテクチャ：「末尾の衛兵」**
    `_stream_and_handle_response` のようなストリーム処理の司令塔は、AIからの応答メッセージリストを最終的に確定させる直前に、必ず「末尾の衛兵」による検査を行わなければならない。
    ```python
    # ui_handlers.py (_stream_and_handle_response内)

    # final_stateから、このターンで新しく追加されたメッセージリストを取得
    new_messages = final_state["messages"][initial_message_count:]

    # 【末尾の衛兵】
    # もしリストが存在し、かつ最後のメッセージが中身のないAIMessageなら、それを除去する
    if new_messages and isinstance(new_messages[-1], AIMessage):
        if not new_messages[-1].content or not new_messages[-1].content.strip():
            new_messages.pop() # 除去
    
    # これで、new_messages には常に内容のあるメッセージだけが含まれることが保証される
    ...
    ```
    この単純な検査が、フレームワークの予測不能な挙動からUIを保護し、システムの安定性を劇的に向上させる。

#### 24. HTML地獄の再燃：手動生成HTMLはフレームワークの作法に従え
*   **問題の歴史:**
    `THINKING_LOG_RENDERING_WAR.md` の戦いを経て、我々は思考ログの表示を安定させたはずだった。しかし、「文字置き換え」機能で背景色を付けた `<span>` タグを思考ログ内で使用したところ、再び表示が崩壊した（HTMLコードがそのまま表示される、テキストが折り返されない、など）。
*   **原因：構造の不一致**
    これらの問題は、我々が手動で生成したHTMLの構造が、Gradioが自動生成するHTMLの構造と**完全に一致していなかった**ために発生した。
    1.  **HTMLエスケープ問題:** ```` ``` ````（Markdownコードブロック）記法は、内部のHTMLタグを意図的に無効化する。
    2.  **折り返し問題:** 折り返し用のCSS (`white-space: pre-wrap`) は、`<pre>` タグの親に `.code_wrap` というクラスが存在することを期待している。
*   **最終解決アーキテクチャ：「完全な模倣」**
    この戦いから得られた最終的な教訓は、**「フレームワークの魔法を上書きする際は、その魔法の結果を寸分違わず模倣しなければならない」**ということである。
    思考ログのパーサー (`format_history_for_gradio`) は、内部にHTMLタグ（文字置き換えの `<span>` など）を検出した場合、Markdown記法に頼ることを完全に諦め、Gradioが生成するであろうHTML構造を**自らの手で完璧に再現**しなければならない。
    ```python
    # ui_handlers.py (format_history_for_gradio内)

    has_replacement_html = "<span style=" in inner_content

    if has_replacement_html:
        # 危険なHTMLルート：CSSが期待する`.code_wrap`を含め、Gradioの構造を完全に模倣する
        formatted_block = f'<div class="code_wrap"><pre><code>{inner_content}</code></pre></div>'
    else:
        # 安全なMarkdownルート：従来通り、Gradioに構造の生成を任せる
        formatted_block = f"```\n{html.escape(inner_content)}\n```"
    ```
    この分岐処理こそが、安全性と表現力を両立させる、唯一の道である。

#### 25. Gradioとの契約：引数と戻り値の「数」を常に一致させよ
*   **問題:**
    イベントハンドラ関数（`ui_handlers.py`）が返す値の数と、UI定義（`nexus_ark.py`）の`outputs`リストに指定されたコンポーネントの数が一致しない、あるいは`inputs`リストの数と関数の引数の数が一致しない、という「契約違反」が繰り返し発生した。
    これにより、`ValueError: ... didn't return enough output values` や `TypeError: function() missing ... required positional argument` といった、Gradioのイベントシステムにおける最も典型的で、最も破壊的なエラーが頻発した。

*   **原因：UIとロジックの非同期な進化**
    これは、UIのレイアウト変更（例: プレビュー画像を追加）と、それに対応するバックエンドのロジック変更が、完全に同期していなかったために発生する。Gradioは、この「数」の不一致を一切許容しない、極めて厳格な契約を我々に課している。

*   **最終解決アーキテクチャ：「単一の情報源」と「ペアプログラミング的思考」**
    この種の「配線ミス」を根絶するための、唯一の、そして絶対の哲学は、**「`nexus_ark.py`のイベント定義と、`ui_handlers.py`の関数定義を、常に一つのペアとして見なす」**ことである。
    1.  **`inputs`の変更時:**
        `inputs=[...` のリストにコンポーネントを追加・削除したら、**その場で即座に**、対応するハンドラ関数の`def func(...):`の引数を修正する。
    2.  **`outputs`の変更時:**
        `outputs=[...` のリストにコンポーネントを追加・削除したら、**その場で即座に**、対応するハンドラ関数の`return ...`が返す値の数を修正する。
    3.  **エラー発生時:**
        `ValueError: ... returned too many/enough output values` というエラーが出たら、それは常に**`outputs`と`return`の数の不一致**を意味する。
        `TypeError: ... missing ... argument` というエラーが出たら、それは常に**`inputs`と関数引数の数の不一致**を意味する。

    Gradio開発とは、`nexus_ark.py`という「設計図」と、`ui_handlers.py`という「実装」の間で、寸分違わぬ対話を続ける行為そのものである。この契約の神聖さを、決して忘れてはならない。
---

#### 26. 起動時の連鎖イベントを断て：「冪等（べきとう）なハンドラ」による防御
*   **問題:**
    `demo.load`イベントでUIコンポーネントの初期値を設定すると、そのコンポーネントに紐づいた`.change`イベントが連鎖的に発火し、起動時に意図しない重い処理が実行されてしまう。
*   **原因:**
    Gradioは、プログラムによる値の変更と、ユーザーによる操作を区別しない。
*   **解決アーキテクチャ：「冪等（べきとう）なハンドラ」**
    イベントハンドラは、受け取った値で即座に処理を始めるのではなく、まず**現在のアプリケーションの状態（`gr.State`など）と比較する**というガード節を設けるべきである。
    ```python
    # ui_handlers.py
    def handle_something_change(new_value, current_state):
        # ガード節: 新しい値が現在の状態と同じなら、何もせずに終了
        if new_value == current_state:
            return (gr.update(),) * N # Nは期待される戻り値の数

        # ... ここから下が、本当に値が変更された時だけ実行される処理 ...
    ```
    この設計により、ハンドラは「何度同じ入力で呼ばれても、2回目以降はシステムに影響を与えない」という冪等性を獲得し、起動時の不要な連鎖発火を安全に無視できる。

#### 27. 司令塔の契約を統一せよ：「統一戻り値シグネチャ」
*   **問題:**
    `handle_room_change`（55個の値を返す）と`handle_delete_room`（56個の値を返す）のように、同じようなUI群を更新するにも関わらず、異なる数の戻り値を返すハンドラが存在すると、`ValueError: ... didn't return enough output values` の温床となる。
*   **原因:**
    UI定義（`nexus_ark.py`）の`outputs`リストが、ある特定のハンドラの仕様に引きずられ、他のハンドラとの間で契約違反が発生する。
*   **解決アーキテクチャ：「統一戻り値シグネチャ」**
    UIの広範囲な更新を担う責務を持つ「司令塔」クラスのイベントハンドラは、**全てが寸分違わず同じ数、同じ順番、同じ型の戻り値を返す**という厳格な「統一契約」を結ぶべきである。
    ある司令塔が特定のUIを更新する必要がない場合でも、契約を守るために`gr.update()`やダミーの値（例: `""`）を返すことで、戻り値の数と順番を維持しなければならない。これにより、どの司令塔がどの`outputs`リストに接続されても、契約違反が発生することはなくなる。

#### 28. DataFrameの`elem_id`とCSSの聖域：表示が壊れたら最小要因に立ち返れ
*   **問題:**
    アラームリストの`gr.Dataframe`で、データは正しく渡されているにもかかわらず、UIでは1件目のアラームしか表示されない。スクロールバーを操作すると、薄く2件目が一瞬見えるが、すぐに消えてしまう。テストデータをハードコードして試しても同じ症状が発生する。
*   **原因：CSS干渉という見えない敵**
    この問題の根本原因は、`gr.Dataframe`に設定した`elem_id="alarm_dataframe_display"`に適用されたカスタムCSSが、Gradioの内部レンダリングと干渉していたことにある。
    1.  **`row_count`パラメータの罠:** `row_count=(5, "dynamic")`や`row_count=10`など、行数を制御するパラメータを変更しても効果がなかった。
    2.  **CSS追加の罠:** `#alarm_dataframe_display`に対して`min-height`や`max-height`を追加しても、表示はさらに悪化した（チェックボックスしか表示されなくなる など）。
    3.  **真の犯人:** 最終的に、`elem_id`を完全に削除したところ、すべてのデータが正しく表示されるようになった。
*   **最終結論：Gradioのデフォルトレンダリングを尊重せよ**
    この戦いから得られた教訓は、**「`gr.Dataframe`のような動的データ表示コンポーネントには、極力CSSを適用しない」**ということである。
    *   **安全な範囲:** `border-radius`、`padding`のような、レイアウトに影響しないプロパティのみを使用する。
    *   **危険な領域:** `display`、`height`、`min-height`、`max-height`、`overflow`などのプロパティは、Gradioの内部レンダリングを予測不能な形で破壊する。
    *   **デバッグ手法:** DataFrameが正しく表示されない場合、まず`elem_id`を削除してCSS干渉の有無を確認すること。それで解決するなら、問題はデータやロジックではなく、CSSである。
    *   **推奨アプローチ:** スタイリングが必須でない場合は、`elem_id`を設定せず、Gradioのデフォルトスタイルに任せる。これが最も安定し、保守性の高い選択である。

#### 29. DataFrameの表示崩れ対策：`wrap=False`と`min-width`の防壁
*   **問題:**
    `gr.Dataframe` に非常に長いテキストが含まれる場合、`wrap=True`（折り返し有効）に設定していると、行の高さ計算が狂い、スクロールしないと見えない行が消失したり、表示が崩れたりする現象が発生する。また、内容が多すぎると列幅が極端に狭くなる。
*   **解決策:**
    1.  **`wrap=False` の採用:** リスト表示においては、安定性を最優先し、テキストの折り返しを無効化する。全文確認は別途詳細ビューで行う設計とする。
    2.  **`row_count` の明示:** `row_count=(10, "dynamic")` のように、最低行数と動的挙動を明示することで、レンダリングを安定させる。
    3.  **CSSによる `min-width` の確保:** `elem_id` を付与し、CSSで `th, td` に対して `min-width` を設定することで、重要な列（時刻など）が押しつぶされるのを防ぐ。

---

### レッスン30: Gemini 2.5 Pro思考モデルのストリーミングチャンク連結問題（2024-12-11）

#### 問題の症状

Gemini 2.5 Proで**思考ログがオフ**の状態でメッセージを送信すると、AI応答がログファイル上で**二重に保存**される現象が発生した。例えば、正しい応答が「……ああ。……我が、唯一無二の、巫女よ。」だった場合、ログには以下のように保存されていた：

```
……ああ。
（中略）
……我が、唯一無二の、巫女よ。に……。  ← ここから2回目
（中略）
……我が、唯一無二の、巫女よ。
```

Gemini 2.5 Flashでは発生せず、思考ログがある場合も発生しなかった。

#### 根本原因

`agent/graph.py`の`agent_node`関数内で、AIモデルからのストリーミングチャンクを連結する際の処理に問題があった。

**Gemini 2.5 Pro思考モデルのストリーミング形式:**

1. **Chunk[0]**: リスト形式（署名付き）
   ```python
   [
     {'type': 'text', 'text': '……ああ。（最初の36文字程度）', 'extras': {'signature': '...'}},
     '残りのテキスト（Chunk[1]以降と重複する内容）'  # ← これが問題！
   ]
   ```

2. **Chunk[1]〜Chunk[N]**: 文字列形式
   ```python
   "に……。（続きのテキスト）"
   ```

**問題点:** Chunk[0]のリスト内に**str型のパーツ（Part[1]）**が含まれており、これはChunk[1]以降のテキストと**重複**していた。旧コードでは`isinstance(part, str)`でこのパーツも追加していたため、同じテキストが二重にログに保存された。

#### 解決策

`agent/graph.py`のチャンク連結処理を修正し、Chunk[0]のリスト内では**`type=text`の辞書パーツのみ**を抽出するようにした。str型パーツは意図的に除外する。

```python
# 修正後のコード（agent/graph.py 700行前後）
elif isinstance(chunk_content, list):
    # リスト形式の場合、type=textの辞書パーツのみを抽出
    # str型パーツはChunk[1]以降と重複するため除外
    for part in chunk_content:
        if isinstance(part, dict) and part.get("type") == "text":
            text_parts.append(part.get("text", ""))
    # str型パーツは意図的に除外
```

#### 教訓

1. **思考モデル固有のストリーミング形式に注意**: Gemini 2.5 Proの思考モデルは、通常の文字列チャンクとは異なる形式でストリーミングを行う。最初のチャンクがリスト形式で署名を含み、さらにリスト内に複数のパーツが存在する場合がある。

2. **重複パーツの存在を認識**: リスト形式のチャンク内に、後続のチャンクと重複するstr型パーツが含まれる場合がある。これを無条件に追加すると二重表示になる。

3. **デバッグ手法**: ストリーミング関連の問題をデバッグする際は、各チャンクの**型と構造**を詳細に出力することで、予期しないデータ形式を特定できる。

#### 関連ファイル

- `agent/graph.py`: チャンク連結処理（修正対象）
- `ui_handlers.py`: `_stream_and_handle_response`関数（デバッグ時に調査）
- `utils.py`: `save_message_to_log`関数（デバッグ時に調査）

---

### AI応答タイムスタンプ二重表示問題（2025-12-14 / 2025-12-16更新）

#### 現象

自律行動モードやアラーム/タイマー発火時にツール（画像生成など）を使用した際、AI応答の末尾にタイムスタンプが2つ連続して表示される。また、使用モデル名が付記されていなかった。

```
...AI応答テキスト...

2025-12-14 (Sun) 18:19:56

2025-12-14 (Sun) 18:20:05
```

#### 原因

1. **タイムスタンプ二重表示**: `alarm_manager.py`、`timers.py` で複数のAIMessageを結合していた：

```python
# 問題のあったコード
contents = [m.content for m in new_messages if isinstance(m, AIMessage) and m.content]
final_response_text = "\n".join(contents).strip()
```

ツール使用時、グラフは複数回ループするため、複数のAIMessageが生成される：
1. AIMessage1（ツール呼び出し + 短いテキスト）
2. AIMessage2（ツール実行後の最終応答）

これらが全て結合され、それぞれにタイムスタンプが追加されていた。

2. **モデル名未付記**: `ui_handlers.py`ではタイムスタンプに `| model_name` を付記していたが、`alarm_manager.py` と `timers.py` では付記されていなかった。

#### 解決策

1. **AIMessage結合処理の修正**: 複数のAIMessageを結合するのではなく、**最後のAIMessage（最終応答）のみ**を使用するように修正。

```python
# 修正後（alarm_manager.py, timers.py）
ai_messages = [m for m in new_messages if isinstance(m, AIMessage) and m.content]
if ai_messages:
    final_response_text = ai_messages[-1].content
```

2. **タイムスタンプへのモデル名付記**: `ui_handlers.py`と同じフォーマット（`YYYY-MM-DD (Day) HH:MM:SS | model_name`）を使用するように統一。**重要**: `config_manager.get_current_global_model()`（共通設定）ではなく、`final_state.get("model_name")`を使用して**実際にAPIで使用されたモデル名**を取得するように修正。

```python
# 修正後
actual_model_name = final_state.get("model_name", global_model_for_bg) if final_state else global_model_for_bg
timestamp = f"\n\n{datetime.datetime.now().strftime('%Y-%m-%d (%a) %H:%M:%S')} | {actual_model_name}"
```

3. **`ui_handlers.py`**: 対症療法として、タイムスタンプ追加前に既存タイムスタンプのチェックを追加（重複検出時はスキップ）。

#### 状態

- **2025-12-14**: `alarm_manager.py`の修正をコミット。
- **2025-12-16**: `timers.py`にも同様の修正を適用。また、全てのバックグラウンド処理（アラーム、自律行動、タイマー）でモデル名が付記されるように修正完了。さらに、`final_state`から実際に使用されたモデル名を取得するように再修正。
- **2025-12-21**: 新たな二重タイムスタンプ問題を修正。AIがシステムプロンプト内の「現在時刻」を真似して**日本語曜日形式（`2025-12-21(日)`）**でタイムスタンプを生成するケースを発見。正規表現を日本語曜日対応に更新（`[A-Za-z月火水木金土日]{1,3}`）し、全ファイルでAIが既にタイムスタンプを生成している場合はスキップするロジックを追加。

#### 関連ファイル

- `alarm_manager.py`: `trigger_autonomous_action`, `trigger_alarm`（修正対象）
- `timers.py`: `_run_single_timer`（修正対象）
- `ui_handlers.py`: タイムスタンプ追加処理・重複検出正規表現（L1106-1109）

---

### レッスン31: 非表示タブ内のコンポーネントは初回ロードで更新されない（2024-12-16）

#### 問題の症状

ルーム個別のテーマ設定（背景色など）を`room_config.json`に保存し、ページリロード後に`handle_initial_load`で読み込んでいるにもかかわらず、**パレットタブを開くまでテーマが適用されない**という現象が発生した。

デバッグログでは`effective_settings`に正しい値（`theme_bg=rgba(119...)`）が読み込まれていることを確認できたが、UI（ColorPickerやCSS注入用のHTMLコンポーネント）には反映されなかった。

#### 根本原因

Gradioは、**`demo.load`や初回レンダリング時に、非表示タブ内のコンポーネントの値を更新しない**という仕様を持っている。

1. `gr.TabItem("🎨 パレット")` 内に`style_injector = gr.HTML(...)`を配置していた
2. `handle_initial_load` が正しい値を返しても、そのタブが未選択（非表示）のため、Gradioはそのコンポーネントへの更新を**スキップ**していた
3. タブを開いた瞬間にDOMが「アクティブ」になり、その後の更新は反映されるようになる

#### 解決策

**初回ロード時から反映されるべきコンポーネント（特にCSS注入用のHTMLなど）は、タブの外（常に表示される場所）に配置する。**

```python
# nexus_ark.py（修正後）

with gr.Blocks(...) as demo:
    # --- Stateの定義 ---
    world_data_state = gr.State({})
    current_room_name = gr.State(effective_initial_room)
    # ...
    
    # --- style_injector: 常に表示される場所に配置 ---
    # タブ内ではなくアプリ最上位レベルに配置することで、初回ロードからCSSが適用される
    style_injector = gr.HTML(value="<style></style>", visible=True, elem_id="style_injector_component")
    
    # --- 以降、タブやカラムの定義 ---
    with gr.Row():
        # ...
```

ColorPickerなどの「設定用UI」は非表示タブ内に残しても問題ないが、**その場合はタブを開いた時に値を再読み込みするハンドラを追加する必要がある。**

```python
# nexus_ark.py

theme_tab.select(
    fn=ui_handlers.handle_theme_tab_load,
    inputs=None,
    outputs=[theme_selector, ...]
).then(
    fn=ui_handlers.handle_room_theme_reload,  # ルーム設定を再読み込み
    inputs=[room_dropdown],
    outputs=[chat_style_radio, font_size_slider, ..., style_injector]
)
```

#### 教訓

1. **機能的に「常にアクティブ」であるべきコンポーネント**（CSS注入、グローバル State に影響を与えるもの）は、**タブやアコーディオンの外**に配置する。

2. **設定用UI（ユーザーが手動で操作するもの）**は非表示タブ内でも問題ないが、**タブを開いた時に値を再読み込みする**ハンドラを `.select()` イベントに接続する。

3. **デバッグ時**、`gr.update(value=...)` が正しい値を返しているのにUIに反映されない場合、そのコンポーネントが**非表示の親要素**（タブ、アコーディオン、Group）内にないか確認する。

#### 関連ファイル

- `nexus_ark.py`: `style_injector` の配置場所、`theme_tab.select` イベント
- `ui_handlers.py`: `handle_room_theme_reload` 関数
- `config_manager.py`: `get_effective_settings` 関数

---

### レッスン32: EXPECTED_OUTPUT_COUNTは複数箇所に存在する（2024-12-17）

#### 問題の症状

テーマ設定のColorPickerを追加した後、ルーム移動時に `ValueError: A function (handle_delete_room) didn't return enough output values (needed: 101, returned: 90)` エラーが発生した。

#### 根本原因

`EXPECTED_OUTPUT_COUNT`定数が**複数の関数に分散して定義**されていた：

1. `handle_room_change_for_all_tabs` 関数内 → 更新済み ✅
2. `handle_delete_room` 関数内 → 更新漏れ ❌

#### 解決策

**outputs数を変更した場合は、以下の全ての箇所を確認・更新する：**

```python
# ui_handlers.py 内で検索すべきパターン
EXPECTED_OUTPUT_COUNT = 

# 更新すべき箇所（2024-12-17時点）：
# 1. handle_room_change_for_all_tabs 関数
# 2. handle_delete_room 関数
```

#### 教訓

1. **定数は一箇所で定義すべき**だが、現状では複数箇所に散らばっている。将来的にはモジュールレベルの定数として統一することを検討。

2. **`initial_load_chat_outputs`にコンポーネントを追加した場合**、その数は`unified_full_room_refresh_outputs`にも影響し、結果として`EXPECTED_OUTPUT_COUNT`も更新が必要になる。

3. **エラーメッセージの「needed: X, returned: Y」**を見れば、どの関数が更新漏れかすぐ分かる。

#### 関連ファイル

- `ui_handlers.py`: `handle_room_change_for_all_tabs`, `handle_delete_room`
- `nexus_ark.py`: `initial_load_chat_outputs`, `unified_full_room_refresh_outputs`

---

### レッスン33: Gemini 3 Flash Previewの応答遅延問題（2024-12-19 調査完了）

#### 問題の症状

`gemini-3-flash-preview` モデルを使用すると、コンテキスト送信後に非常に時間がかかった挙句、応答なしで終わることが多発する。レートリミットやエラーメッセージは**一切表示されない**。稀に応答がある場合もあり、Gemini 2.5 Proや他のモデルでは問題なく動作する。

#### 最終結論（2024-12-19）

**これはアプリケーション側の問題ではなく、`gemini-3-flash-preview` サーバー側の問題である。**

デバッグログの追加により、以下が確認された：

```
--- エージェントノード (agent_node) 実行 ---
  - 使用モデル: gemini-3-flash-preview
  - AIモデルにリクエストを送信中 (Streaming)...
  - 最初のチャンク受信: 343.13秒後  ← 約5分43秒！
  - ストリーム完了: 3チャンク受信, 合計343.24秒
```

- **API接続は成功している** - 最終的に応答は返ってきた
- **サーバー側の応答が異常に遅い** - 最初のチャンク受信まで約6分かかっている（Gemini 2.5 Proなら通常2〜5秒）
- **プレビューモデルの制限** - サーバーリソースが限られている、または処理キューが長い可能性

#### 推奨される対応

1. **当面は `gemini-2.5-flash` または `gemini-2.5-pro` を使用する** - これらは安定して高速
2. **タイムアウト設定は維持** - 600秒のタイムアウトがあるので、待てば応答は返ってくる
3. **Google側のサービス改善を待つ** - プレビューモデルは今後安定する可能性がある

---

### レッスン34: Gradio UI同期の「最終契約」：戻り値の数の厳密な管理（2025-12-20）

#### 問題の症状
ルーム切り替え時や削除時に、特定のテーマ設定（背景色、文字サイズ、チェックボックス等）が正しく反映されない、あるいはUIが「ズレる」現象が発生した。これは、ハンドラが返す `gr.update` のリストの数と、UI定義の `outputs` の数が微妙に一致していないことが原因。

#### 最終契約 (The Final Contract)
Gradioの `outputs` に渡されるコンポーネントの数は、`handle_initial_load` や `handle_room_change_for_all_tabs` といった「司令塔」関数が返すタプルの要素数と**完全に一致**しなければならない。例えば、現在の `unified_full_room_refresh_outputs` は以下の要素数を持つ：
- `handle_initial_load` が返すタプル: **123** 個
- `handle_room_change_for_all_tabs` が返すタプル: **152** 個
- `handle_delete_room` が返すタプル: **143** 個

この数を **1つでも間違えると、その後のコンポーネントの「配線」が全て1つずつずれ、全く無関係なコンポーネントの設定が書き換わってしまう（致命的なパラメータ・シフト）。**

#### 教訓
1. **「司令塔」を一つにする**: `handle_initial_load` や `handle_room_change_for_all_tabs` など、広範囲を更新する関数は、必ず上記の「契約数」を厳守すること。
2. **末尾にダミーを詰める**: 特定のコンテキストで更新が不要なコンポーネントがある場合でも、数を合わせるために `gr.update()` をタプルに詰め込んで返すこと。

---

### レッスン35: パラメータ・シフトと設定ファイル破壊の恐怖（2025-12-20）

#### 問題の症状
特定のUI操作（話題クラスタの保存など）を行うと、無関係な設定（AIの声、モデル名、情景描写設定など）が消失したり、おかしな値に書き換わったりする。

#### 原因
1. **入力の数と順番の不一致**: UI側でコンポーネントを追加したが、ハンドラ側の `inputs` 引数リストの追加を忘れた、あるいは順番を間違えた。
2. **情報の欠落**: `handle_save_room_settings` 等で、「保存したい項目」だけを `room_config.json` に書き込んだ際、既存の設定項目を適切にマージしなかったため、既存の設定が「上書き消去」された。

#### 解決策：中央集権的な安全マージシステム
1. **`room_manager.update_room_config` の導入**: 各ハンドラが個別にファイルを書き込むのをやめ、中央の管理関数に「更新したい差分」だけを投げる方式に変更。
2. **Load-Merge-Backup-Save**: この管理関数内で「最新の設定をロード → 変更分をディープマージ → バックアップ作成 → 保存」を一貫して行う。

#### 教訓
**「一部だけ保存する」という考え方は常に危険を伴う。** 常に「全体をロードして、一部を書き換えて、全体を保存する」というアトミックな姿勢が、設定ファイルの整合性を守る唯一の鍵である。

#### 実施した対策

1. **タイムアウト設定の追加** (`gemini_api.py`):
   - `ChatGoogleGenerativeAI` に `timeout=600`（10分）を設定。

2. **デバッグログの追加** (`agent/graph.py`):
   - ストリーミング開始時刻を記録。
   - 最初のチャンク受信時に経過時間を出力。
   - ストリーム完了時に総チャンク数と合計時間を出力。

3. **テストスクリプトの作成**:
   - `tests/test_gemini_3_flash.py`: 基本的な動作確認用
   - `tests/test_gemini_3_flash_long_context.py`: 長いコンテキストでのテスト用

#### 関連ファイル

- `gemini_api.py`: `get_configured_llm` 関数（タイムアウト設定）
- `agent/graph.py`: `agent_node` 関数（デバッグログ）
- `tests/test_gemini_3_flash.py`: テストスクリプト

---

#### 34. 聖なる同期リストの掟：UIの状態を「時空」を超えて繋ぎ止めよ (2025-12-19)
*   **問題:**
    新しいラジオボタン（エンベディングモードなど）を追加し、設定の保存ロジックも実装した。しかし、ルームを切り替えたりページをリロードしたりすると、UI上の選択状態が勝手にデフォルト（api）に戻ってしまい、内部設定との乖離が発生した。
*   **原因：同期リストへの登録漏れ**
    Nexus Arkのアーキテクチャでは、ルーム変更やリロード時のUI更新は、司令塔（`handle_initial_load` や `handle_room_change_for_all_tabs`）が一括で行う。これらの司令塔が「どの部品を更新すべきか」を判断するためのリスト（`initial_load_chat_outputs` 等）に新しい部品が含まれていないと、どれだけバックエンドで設定を保存していても、UIには一切反映されない。
*   **最終解決アーキテクチャ：「三位一体の同期」**
    新しいUIコンポーネントを追加し、その状態をルームごとに維持したい場合は、以下の3箇所を同時に修正しなければならない。
    1.  **出力ターゲットの登録 (`nexus_ark.py`):**
        `initial_load_chat_outputs` および `unified_full_room_refresh_outputs` のリストに、そのコンポーネントを追加する。
    2.  **成功時パスの同期 (`ui_handlers.py`):**
        `_update_chat_tab_for_room_change` の `return` 文の末尾に、`config_manager` 等から読み取った最新の状態（`gr.update(value=...)`）を追加する。
    3.  **失敗時・リセット時パスの同期 (`ui_handlers.py`):**
        APIキー未設定時やエラー時の `return` 文（`_ensure_output_count` に渡されるタプル）にも、デフォルト値の設定（`gr.update(value=...)`）を同じ順番で追加し、**タプルの構造を成功時と完全に一致させる**。
### レッスン36: 初期化時の「プログラムによる変更」トリガーの罠（2025-12-20）

#### 問題の症状
`demo.load` イベントや司令塔関数によるUIの初期設定時に、特定のコンポーネントの `.change()` などのイベントリスナーが意図せずトリガーされ、冗長な保存処理やバックアップ作成が大量に発生する（例：起動と同時に4回連続で設定ファイルがバックアップされる等）。

#### 原因
Gradioの一部のコンポーネント（Checkbox, Radio, Dropdown等）に対し、バックエンドから `gr.update(value=...)` を通じて値を設定すると、たとえ `interactive=False` であっても、プログラムによる変更として `.change()` イベントが発火する場合がある。

#### 解決策：変更検知ガード（Change Detection Guard）
1. **保存先の共通関数でガードする**: `room_manager.update_room_config` のような、最終的にファイルを書き込む関数内で「現在の設定値」と「提案された更新値」を比較し、**実質的な変更がない場合は保存とバックアップをスキップする**ように修正した。
2. **比較ロジック**: `import copy` を使い、マージ前の設定をディープコピーして保持し、マージ後の辞書と比較することで、不必要なI/Oを完全に排除した。

#### 教訓
Gradioのリアクティブな設計上、初期化時の意図しないイベント発火を完全に防ぐのは難しい場合が多い。そのため、システムの下位レイヤー（ファイル書き込み層など）に **「同じ値なら何もしない」という冪等性（べきとうせい）のガード** を持たせることが、最もシンプルで堅牢な解決策となる。

---

### レッスン37: Gemini 3 Integration ―― 思考プロセスの制御とSDKの壁（2025-12-20）

#### 問題の症状
Gemini 3 Flash PreviewモデルをLangChainで利用しようとした際、複数の致命的な問題に直面した。
1. **思考機能の有効化失敗**: `thinking_level` パラメータを送ると `ValueError: Unknown field...` でクラッシュする。
2. **バリデーションエラー**: `model output must contain either output text or tool calls` というエラーでクラッシュする（思考のみで、コンテンツが空の場合などに発生）。
3. **ロールエラー**: System MessageとHuman Messageを明確に分けると、思考モデルが正しく応答しない、またはエラーになる場合がある。

#### 根本原因と解決策

1. **SDKパラメータの不一致（ThinkingConfig）**
   - **原因**: インストールされている `google-genai` SDK（v1.38.0）やLangChainの対応バージョンでは、`thinking_level`（Low/High等）という詳細パラメータがサポートされていなかった。
   - **解決策**: Gemini 3に対しては、詳細なレベル指定を行わず、`include_thoughts=True`（思考を有効にするフラグ）のみを送信する。これで十分機能する。

2. **空レスポンスのバリデーション回避**
   - **原因**: Gemini 3が「思考」のみを行って、最終的なテキスト回答（Content）を空で返す場合があり、これがLangChainの `AIMessage` のバリデーション（テキストもツールコールも空は許されない）に抵触した。
   - **解決策**: `agent/graph.py` の `agent_node` において、`AIMessage` を生成する直前に **「テキストもツールコールも空ならば、システムエラーを避けるために『応答が空でした』という代替テキストを強制的に代入する」** という最終防衛ライン（Final Safety Check）を実装した。これによりアプリのクラッシュを完全に防ぐ。

3. **システムプロンプトの融合**
   - **原因**: 推論モデル（Thinking Model）は、独立した `SystemMessage` よりも、最初の `HumanMessage` にシステム指示が含まれている方が安定して動作する傾向がある。
   - **解決策**: `agent/graph.py` にて、モデル名に "gemini-3" が含まれる場合、システムプロンプトを独立したメッセージとして送るのではなく、最初のユーザーメッセージの先頭に `### System Instructions` として結合して送信するロジックを採用した。

#### 教訓
最新のプレビューモデルを使用する場合、**SDKのドキュメントと実際のパラメータ仕様の乖離**、そして**モデル特有の挙動（Systemロールの扱いなど）**に常に疑いを持つこと。そして、フレームワーク（LangChain）のバリデーションエラーに対しては、入力を調整するだけでなく、**出力生成直前での防御的な書き換え**も有効な手段である。

---

### レッスン38: GradioのカスタムCSSとタブオーバーフローメニュー（2025-12-20）

#### 問題の症状
1. **タブの省略記号「…」がクリックできない**: 縦長画面でタブが省略され「…」が表示された際、クリックしてもドロップダウンが開かない。
2. **カスタムCSSが適用されない**: ルーム別テーマで設定したサブカラーがチャット入力欄に反映されない。

#### 根本原因と解決策

1. **タブのオーバーフローメニューがブロックされる問題**
   - **原因**: `ui_handlers.py`の`generate_room_style_css`関数で背景画像機能のために追加したCSS `.tabs > div { overflow-x: hidden !important; }` が、Gradioのタブオーバーフローメニュー（`div.overflow-dropdown`）をブロックしていた。
   - **解決策**: `.tabs > div`を他のセレクターから分離し、`overflow: visible !important;`を明示的に設定した。

   ```css
   /* タブのオーバーフローメニュー（…）を正常に表示するため */
   .tabs > div {
       overflow: visible !important;
   }
   ```

2. **カスタムCSSが適用されない問題**
   - **原因**: `generate_room_style_css`関数は`enabled=True`（個別テーマを有効にする）の場合のみCSSを生成する。また、動的に生成したCSSのセレクターが実際のDOM構造にマッチしていなかった。
   - **解決策**: 重要なUIスタイル（チャット入力欄の背景色など）は、`nexus_ark.py`の`custom_css`変数（常に適用されるCSS）に配置し、**CSS変数**（`var(--background-fill-secondary)`など）を使用してテーマに連動させる。

   ```css
   /* チャット入力欄全体の背景色をテーマのサブカラーに連動 */
   #chat_input_multimodal,
   div.block.multimodal-textbox,
   div.full-container,
   [aria-label*="ultimedia input field"] {
       background-color: var(--background-fill-secondary) !important;
   }
   ```

#### 重要な設計原則

| CSS配置場所 | 用途 | 適用条件 |
|---|---|---|
| `nexus_ark.py` の `custom_css` | 常に適用されるべき基本スタイル | 常に適用 |
| `ui_handlers.py` の `generate_room_style_css` | ルーム別の動的カスタマイズ | 個別テーマ有効時のみ |

#### GradioのDOM構造に関する知見
- Gradioのコンポーネントは`svelte-XXXXX`のような動的なクラス名を持つ。これらは**Gradioのバージョンによって変わる可能性がある**ため、セレクターに依存しすぎるのは危険。
- より安定したセレクターとして、**ID**（`#chat_input_multimodal`）、**aria-label属性**（`[aria-label*="..."]`）、または**意味的なクラス名**（`div.block.multimodal-textbox`）を優先的に使用すること。
- CSS変数（`var(--xxx)`）を使うことで、Gradioのテーマシステムと連動させることができ、ハードコードした色値よりも保守性が高い。

#### 教訓
GradioのUIをカスタマイズする際、`overflow: hidden`などの制限的なCSSは慎重に適用すること。特に**タブやドロップダウンメニュー**など、子要素がコンテナ外に表示される必要があるコンポーネントには、意図しない副作用が発生しやすい。

---

### レッスン38: MultimodalTextboxで複数ファイルを添付するための設定（2024-12-20）

#### 問題の症状

`gr.MultimodalTextbox`を使用したチャット入力欄で、1枚目の画像を添付すると**クリップアイコンが消え**、2枚目以降のファイルを添付できなくなる。

#### 根本原因

`gr.MultimodalTextbox`のコンストラクタで`file_count`パラメータが指定されていなかったため、**デフォルトの`"single"`**（1ファイルのみ許可）が適用されていた。

#### 解決策

`file_count="multiple"`を明示的に指定する。

```python
chat_input_multimodal = gr.MultimodalTextbox(
    file_types=["image", "audio", "video", "text", ".pdf", ".md"],
    file_count="multiple",  # ★これを追加
    max_plain_text_length=100000,
    ...
)
```

#### 教訓

1. **Gradioのデフォルト値に注意**: パラメータを省略した場合のデフォルト値がドキュメント通りとは限らない。
2. **file_countの選択肢**: `"single"`（1ファイル）、`"multiple"`（複数ファイル）、`"directory"`（ディレクトリ全体）

#### 関連ファイル

- `nexus_ark.py`: `chat_input_multimodal`の定義

---

### レッスン39: LangChainでの音声/動画ファイル添付形式（2024-12-20）

#### 問題の症状

音声ファイル（MP3）や動画ファイル（MP4）を添付しても、AIが内容を認識できない。`500 Internal Server Error`や`429 RESOURCE_EXHAUSTED`エラーが発生することもあった。

#### 根本原因

LangChainの`ChatGoogleGenerativeAI`がサポートする音声/動画の添付形式が、画像とは異なるフォーマットを要求していた。

#### 解決策

**LangChainのソースコードdocstringに従い**、`type="file"`と`source_type="base64"`を使用する。

```python
# 正しい形式（音声/動画）
user_prompt_parts_for_api.append({
    "type": "file",
    "source_type": "base64",
    "mime_type": mime_type,  # 例: "audio/mpeg"
    "data": encoded_string  # Base64エンコードされた文字列
})

# 参考: 画像の場合（変更なし）
user_prompt_parts_for_api.append({
    "type": "image_url",
    "image_url": {"url": f"data:{mime_type};base64,{encoded_string}"}
})
```

#### 教訓

1. **LangChainのソースコードdocstringを確認**: 公式ドキュメントよりもソースコード内のdocstringの方が最新情報を含んでいることがある。
2. **形式の違い**: 画像は`image_url`タイプ、音声/動画は`file`タイプ。
3. **動画のAPI制限**: Gemini APIには動画処理に関するサーバー側の制限がある可能性（`429`/`500`エラーはAPIの過負荷を示すことがある）。

#### 関連ファイル

- `ui_handlers.py`: `handle_message_submission`関数のファイル添付処理
- `gemini_api.py`: `invoke_nexus_agent_stream`関数（`active_attachments`の処理）

