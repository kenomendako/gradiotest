# Nexus Ark 開発ドキュメント：Gradio起動時イベント連鎖問題の教訓

## 1. 概要

本文書は、Nexus Arkのアプリケーション起動時に、複数の情景更新処理が意図せず連鎖的に実行されてしまう問題の調査、試行錯誤の全記録、そして最終的な解決策をまとめたものである。

この問題は、Gradioのイベントモデルの根源的な仕様に起因するものであり、同様の問題に再発または遭遇した際の、重要な参照資料となる。

## 2. 問題の現象と根本原因

### 現象

-   アプリケーションを起動すると、ターミナルに情景生成や場所移動のログが複数回（4〜5回）連続で表示される。
-   特にAPIキーが未設定の状態では、APIキーエラーのUI通知が複数回ポップアップし、ユーザー体験を著しく損なう。

### 根本原因

Gradioの`demo.load`イベントは、アプリケーション起動時に各UIコンポーネントの初期値を設定する。この際、プログラムによって値が設定されたコンポーネントに`.change`イベントが紐づいていると、Gradioはそれを**ユーザーによる操作と区別せず、関連するイベントハンドラをトリガーしてしまう。**

Nexus Arkでは、以下のUIコンポーネントが`handle_initial_load`によって初期化され、それぞれが情景更新をトリガーするハンドラに接続されていたため、イベントの連鎖が発生していた。

1.  **時間設定モード** (`gr.Radio`)
2.  **季節選択** (`gr.Dropdown`)
3.  **時間帯選択** (`gr.Dropdown`)
4.  **場所選択** (`gr.Dropdown`)

## 3. 解決に至らなかったアプローチの記録

この問題を解決するため、数々の仮説を立てて修正を試みたが、いずれもGradioのイベントモデルの複雑さの前に失敗に終わった。

-   **失敗策1: イベントトリガーの変更 (`.select`)**
    -   **仮説:** ユーザーのクリック操作でのみ発火する`.select`を使えば、プログラムによる初期化では発火しない。
    -   **敗因:** `.change`と`.select`では、ハンドラに渡されるイベントオブジェクトの型が異なり、引数の不一致による`TypeError`が発生した。

-   **失敗策2: イベントソースの判定 (`evt.is_trusted`)**
    -   **仮説:** イベントオブジェクトの`is_trusted`属性で、ユーザー操作起因のイベントのみを処理する。
    -   **敗因:** 全てのコンポーネントの`.change`イベントが、`is_trusted`属性を持つイベントオブジェクトを渡すわけではなかったため、`AttributeError`が発生した。

-   **失敗策3: 「起動中フラグ (`gr.State`)」による制御**
    -   **仮説:** アプリケーション起動中を示す`gr.State`フラグを導入し、ハンドラ側でこのフラグをチェックして処理をスキップさせる。
    -   **敗因:** Gradioのイベントループは非同期的であり、**ハンドラが実行されるタイミングでは、まだフラグが期待通りに更新されていない**という競合状態（レースコンディション）が発生した。結果として、このフラグは機能しなかった。

## 4. 最終解決アーキテクチャ：「冪等（べきとう）なハンドラ」

タイミングに依存するフラグ管理の不安定さを排除し、Gradioのイベント発火の挙動に一切依存しない、以下の堅牢なアーキテクチャを採用した。

### 設計思想

イベントハンドラの**「冪等性（Idempotency）」**を確保する。つまり、「ハンドラが何度同じ引数で実行されても、システムの状態が初回実行時と同じ結果になる」ように設計する。

これを実現するため、ハンドラは受け取ったイベントの値だけを信じるのではなく、**必ず永続化されている現在の状態と比較し、本当に変更が必要な場合のみ処理を実行する。**

### 実装

-   **`handle_location_change` (場所移動ハンドラ)**
    1.  イベントが発火したら、まず`current_location.txt`から現在の場所を取得する。
    2.  UIから渡された`selected_value`と、ファイルから読み込んだ値を比較する。
    3.  **両者が同じであれば、起動時の冗長な呼び出しと判断し、何もせずに即座に`return`する。**
    4.  値が異なる場合のみ、ユーザーによる実際の操作とみなし、場所の書き込みと情景更新を実行する。

-   **`handle_time_settings_change_and_update_scenery` (時間設定ハンドラ)**
    1.  イベントが発火したら、まず`room_config.json`から現在の時間設定（モード、季節、時間帯）を取得する。
    2.  UIから渡された値と比較する。
    3.  **設定に変更がなければ、APIコールを伴う情景更新を行わず、即座に`return`する。**

## 5. 導き出された普遍的な教訓

この一連の問題から、Gradioアプリケーションを堅牢に開発するための、以下の重要な教訓が得られた。

1.  **Gradioは、プログラムによる値の変更とユーザー操作を区別しない。**
    `.change`イベントは、値が変化するあらゆる可能性を想定して設計する必要がある。

2.  **イベント発火のタイミングと状態の伝播は、信頼できないブラックボックスである。**
    あるイベントで`gr.State`を更新し、別のイベントがその更新された値を即座に読めるという保証はない。タイミングに依存したフラグ管理は、競合状態の温床となるため避けるべきである。

3.  **ハンドラは「冪等」に設計せよ。**
    ハンドラ自身が、永続化されたデータ（ファイルやデータベース）とUIからの値を比較し、「本当にこの処理を実行する必要があるか」を判断するガード節を設けること。これが、Gradioのイベントモデルの気まぐれに対する、最も確実な防御策である。