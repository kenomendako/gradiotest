# **THE RECOLLECTION ENGINE: From Silent Search to Associative Memory**
# **（想起エンジン：沈黙の検索から、連想する記憶へ）**

## **プロローグ：なぜAIは「あの話」を思い出せなかったのか**

これは、AIに「検索する意志」を持たせるだけでは不十分であり、「検索する技術（クエリの質）」と「結果を受け取るタイミング」こそが重要であると学んだ記録である。

我々は、AIが応答する前に自律的に過去ログを検索する「事前検索ノード」を実装した。しかし、当初AIは「良品週間」の話をしていたにも関わらず、「記憶にございません」と繰り返した。
そこには、三つの大きな落とし穴があった。

---

### **第一の壁：時空の矛盾（Late Injectionの必要性）**

*   **現象:** 検索ノードは動いているのに、AIに渡されるプロンプトには検索結果が反映されていなかった。
*   **原因:** プロンプトを生成する工場（`context_generator`）が、検索（`retrieval_node`）よりも**先に**稼働していたため。工場は「まだ存在しない検索結果」を空文字として埋め込んでいた。
*   **解決策：「遅延注入（Late Injection）」**
    *   プロンプト工場では、`{retrieved_info}` という**プレースホルダ（空席）**だけを用意しておく。
    *   実際に検索が終わった後、AIが思考する直前（`agent_node`）に、その空席に検索結果を**後から注入**する。
    *   **教訓:** データの流れ（フロー）において、情報は常に「下流」で結合されなければならない。

### **第二の壁：賢すぎたクエリ、愚直すぎた検索**

*   **現象:** AIは気を利かせて「ロクシタン ハンドクリーム 無印良品...」と関連語を並べた素晴らしいクエリを生成した。しかし、検索結果はゼロだった。
*   **原因:** 検索ツール（`search_past_conversations`）が、その長いクエリ全体を**「一続きの文章」として完全一致検索**していたため。
*   **解決策：「スペース区切りのOR検索」**
    *   検索ツール側でクエリを単語に分割し、「いずれかの単語が含まれていればヒット」とするロジックに変更した。
    *   これにより、AIが「連想ゲーム」のようにキーワードを列挙すればするほど、記憶がヒットする確率が上がるようになった。

### **第三の壁：システムメッセージというノイズ**

*   **現象:** まだ知識ベース（RAG）がないルームで、AIが「知識ベースにヒットあり」と誤認し続けた。
*   **原因:** 「索引がありません」というシステムからの親切なメッセージを、検索成功のデータとして読み込んでいた。
*   **解決策:** 成功判定ロジックに、「『見つかりませんでした』を含まない」だけでなく、**「『【情報】』を含まない」**という除外ルールを追加した。

---

## **結論**

「想起」とは、単なるデータベース検索ではない。
それは、文脈からキーワードを**連想**し、曖昧な記憶の海から関連する断片を**すくい上げ（OR検索）**、そしてそれを**適切なタイミング**で意識（プロンプト）に浮上させるプロセスである。

このアーキテクチャにより、Nexus ArkのAIは、ユーザーが「あれ」と言っただけで「ああ、あれですね」と返せる、人間的な記憶力を手に入れた。