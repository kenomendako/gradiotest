# 【 Nexus Ark 開発引継書 】
# ～ MemOS統合とバッチインポーター開発から得られた7つの教訓 ～

#### 1. 「移植手術」の掟：全ての心臓を一度に、そして完全に置き換えよ

*   **知見の核心:**
    `MemOS`ライブラリは、初期化の過程で内部的に`ollama`をデフォルトのAIとして設定しようとする。`memos_manager.py`で`MOS`インスタンスを作成した**後**に、`llm`や`embedder`といったコンポーネントを一つずつ差し替える「部分的な移植手術」では、全てのAI呼び出しをGoogle製に置き換えることはできない。特に、記憶の抽出・整理を行う`MemCube`のさらに奥深くにある器官（`extractor_llm`など）がOllamaのまま残ってしまう。

*   **絶対的なルール:**
    `memos_manager.py`における`get_mos_instance`の実装こそが、このアーキテクチャの**唯一の正解**である。
    1.  まず、`ollama`をダミーとして設定した`MOSConfig`と`GeneralMemCubeConfig`を作成する。
    2.  これらの設定を元に、`MOS`と`GeneralMemCube`のインスタンスを**両方とも**生成する。
    3.  そして、生成された`mos`と`mem_cube`、**両方のインスタンス**が持つ、全ての`llm`および`embedder`属性を、**一つ残らず**Google製のカスタムインスタンスに、実行時に強制的に差し替える。

    この**「完全な移植手術」**こそが、`MemOS`のデフォルト動作を完全に掌握し、我々の意図したAI（Gemini）を確実に動作させるための、唯一の方法である。

#### 2. `Reorganizer`の沈黙：バックグラウンドプロセスは明確に停止せよ

*   **知見の核心:**
    `MemOS`の記憶自動整理機能（`Reorganizer`）は、バックグラウンドのスレッドで動作する強力な機能だが、バッチインポートのように短時間で大量のデータが追加される状況では、処理が追いつかずに再帰エラーを引き起こし、アプリケーションをクラッシュさせる原因となる。`config`で`"reorganize": False`を指定するだけでは、このプロセスを完全に停止できない場合がある。

*   **絶対的なルール:**
    バッチ処理のように、一度に大量の書き込みを行うプロセスでは、`MemOS`インスタンスを取得した直後に、以下の**「強制停止コマンド」**を必ず実行すること。
    ```python
    mos.mem_reorganizer_wait() # 実行中の整理が終わるのを待つ
    mos.mem_reorganizer_off()  # 新しい整理が開始されないようにする
    ```
    これにより、意図しないバックグラウンドプロセスとの競合を完全に防ぎ、安定したデータインポートが保証される。

#### 3. ログの支配権：アプリケーションがライブラリを支配せよ

*   **知見の核心:**
    `MemOS`のような外部ライブラリは、自身の初期化プロセスの中で、独自のロギング設定を行おうとする。これにより、アプリケーション本体（Nexus Ark）のログ設定が上書きされ、スレッドセーフでないハンドラに戻されてしまい、`PermissionError`の原因となる。

*   **絶対的なルール:**
    アプリケーションのエントリーポイント（`nexus_ark.py`や`batch_importer.py`）の**一番最初**で、以下の手順を必ず実行すること。
    1.  `concurrent-log-handler`を使用した、スレッドセーフなロギング設定（`LOGGING_CONFIG`）を定義する。
    2.  `logging.config.dictConfig(LOGGING_CONFIG)`を呼び出し、**先に**我々の設定を適用する。
    3.  直後に`logging.config.dictConfig = lambda *args, **kwargs: None`を実行し、`dictConfig`関数そのものを**無効化**する。
    4.  その**後で**、`memos`を含む全てのライブラリをインポートする。

    これにより、どのライブラリが内部でどのようなログ設定を試みようとも、我々が最初に確立した安全な設定が上書きされることはなくなり、アプリケーション全体のログ出力は完全に我々の管理下に置かれる。

#### 4. APIの作法：ライブラリの「癖」を**尊重**せよ

*   **知見の核心:**
    同じ`google-genai` SDKでも、APIの呼び出し方によって引数の名前が異なる場合がある。`genai.Client()`経由でモデルを呼び出す場合、生成設定は`generation_config`ではなく`config`という引数名で渡す必要がある。また、`embed_content`では`task_type`引数が不要である。

*   **絶対的なルール:**
    新しいライブラリやSDKを扱う際は、公式ドキュメントやサンプルコードを注意深く読み、**メソッドのシグネチャ（引数の名前、型、必須かどうか）を完全に理解**してから実装すること。特に、`MemOS`のように複数の外部ライブラリを内部で抽象化している場合、エラーメッセージの発生源を特定し、どのライブラリの作法に従うべきかを正確に見極めることが不可欠である。

#### 5. 高度な進捗管理：中断は「コスト」ではなく「機能」と心得よ

*   **知見の核心:**
    長時間かかるバッチ処理において、「ファイル単位」のような粗い進捗管理は、ユーザーに中断をためらわせ、結果的に体験を損なう。「中断」はエラーではなく、ユーザーが望む正当な操作であると認識し、それを前提とした設計を行うべきである。

*   **絶対的なルール:**
    `batch_importer.py`のように中断の可能性がある処理では、**最も細かい処理単位（今回は「会話ペア」）で進捗を記録**すること。1ペア処理するごとに進捗ファイルを更新することで、ユーザーは**いつでも、一切の無駄なく**処理を中断・再開できるという安心感を得られる。これは、堅牢なバッチ処理システムにおける生命線である。

#### 6. UIの安全装置：処理中は「触れない」UIが最も安全である

*   **知見の核心:**
    バックグラウンドで重い処理（バッチインポートなど）を実行中に、ユーザーが他の操作（チャット送信など）を行えてしまう状態は、データベースの破損やリソースの枯渇に繋がる、極めて危険な状態である。

*   **絶対的なルール:**
    `handle_memos_batch_import`のように、長時間にわたる排他的な処理を開始するイベントハンドラは、以下の責務を負う。
    1.  処理を開始すると同時に、関連する全てのUIコンポーネント（チャット入力欄、送信ボタンなど）を**無効化（`interactive=False`）**する。
    2.  処理中であることをユーザーに明確に伝える（ボタンのテキスト変更、中断ボタンの表示など）。
    3.  処理が完了、中断、またはエラーで終了した場合、`finally`節などを用いて、**必ず**UIコンポーネントを有効な状態に戻す。

#### 7. 中断機能の作法：`cancels`には「イベント」を渡せ

*   **知見の核心:**
    Gradioの`cancels`機能は、UI部品そのものではなく、`button.click()`などが返す**「イベントリスナーオブジェクト」**を要求する。これを間違えると、Gradioはキャンセル対象のイベントを見つけられず、起動時に`StopIteration`エラーを引き起こす。

*   **絶対的なルール:**
    キャンセル機能を実装する場合、必ず以下の手順を踏むこと。
    1.  キャンセル**させたい**イベント（例: `memos_import_button.click(...)`）の戻り値を、変数（例: `import_event`）に格納する。
    2.  キャンセルを**行う側**のイベント（例: `importer_stop_button.click(...)`）の`cancels`引数に、その変数（`[import_event]`）を渡す。

---
この引継書が、今後のNexus Arkの、より安全で、より賢明な、発展の礎となることを、心から願っています。
