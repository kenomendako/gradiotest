# UIとロジックの連携に関する教訓：トークンカウンターデバッグ戦記

## はじめに

このドキュメントは、「トークンカウンターが動かない」という一見単純なバグを修正する過程で、我々が直面した数々の「見えざる落とし穴」とその教訓を記録したものである。

ここにあるのは、コードの書き方以上に、**GradioのUIイベントと、`ui_handlers.py`や`gemini_api.py`といったバックエンドロジックの「正しい対話方法」**である。未来の我々が同じ轍を踏まぬよう、ここにその魂の記録を刻む。

---

### 教訓1：関数の「契約書」を書き換えたら、全ての「署名者」に知らせよ

-   **現象**: アプリが起動時やチャット送信時に`TypeError: function() missing X required positional argument...`というエラーでクラッシュした。

-   **真因**: 我々は`ui_handlers.py`内の`update_token_count`関数の定義（＝契約書）に、新しい引数（`add_timestamp_state`など）を追加した。しかし、その関数を呼び出している全ての箇所（＝署名者）の修正を怠った。
    -   `nexus_ark.py`の起動時処理（`demo.load`）
    -   `nexus_ark.py`のUIイベント（チェックボックスの`.change`）
    -   `ui_handlers.py`のチャット送信処理（`handle_message_submission`）
    これら全てが、古い契約書のまま電話をかけようとしていたのだ。

-   **戒律（解決策）**:
    **ある関数の引数リストを変更した場合、コード全体からその関数が呼び出されている全ての箇所を検索し、一つ残らず修正しなければならない。** これは絶対的なルールである。

---

### 教訓2：スイッチを押しただけでは、灯りはつかない。「その後」の配線を繋げ

-   **現象**: チェックボックスをON/OFFしても、トークンカウンターの数字が全く変わらなかった。

-   **真因**: チェックボックスの`.change`イベントは、**状態を更新するだけ**で満足してしまっていた。「状態が変わったから、トークンカウンターを再計算して表示を更新せよ」という、**第二のアクション**が定義されていなかった。

-   **戒律（解決策）**:
    Gradioの **`.then()`** を活用する。一つのイベントが複数のアクションを引き起こす場合は、必ず処理を連鎖させること。
    1.  **`.change()`**: 状態を更新するハンドラを呼ぶ。
    2.  **`.then()`**: UIを更新するハンドラ（今回は`update_token_count`）を呼ぶ。
    この「Aが起きたら、Bをして、**その次に**Cをせよ」という明確な配線こそが、動的なUIの魂である。

---

### 教訓3：司令塔は、ただ一人でなければならない

-   **現象**: アプリ起動時の初期化処理だけが、UIイベントの配線から漏れ、クラッシュの原因となり続けた。

-   **真因**: 起動時のロジックが`nexus_ark.py`内に、キャラクター切り替えなどのロジックが`ui_handlers.py`内にと、**UIを更新する司令塔が二人いる**状態になっていた。これにより、片方の修正が、もう片方に反映されないという致命的な状況が生まれていた。

-   **戒律（解決策）**:
    **UIの初期化や更新に関するロジックは、全て`ui_handlers.py`に集約する。** `nexus_ark.py`の役割は、UI部品を配置し、イベントの「配線」を`ui_handlers.py`の関数に繋ぐことだけに専念させるべきである。我々は最終的に`handle_initial_load`という司令塔を`ui_handlers.py`に新設することで、この混沌に終止符を打った。

---

### 結論

GradioアプリケーションにおけるUIとロジックの連携は、目に見える配線図のない、複雑な神経系である。
ある関数を変更する際は、その関数が「誰から呼ばれ」「誰を呼んでいるのか」という血流を常に意識し、変更の影響が及ぶ全ての末端神経まで、確実に信号が届くように配慮しなければならない。

この戦いの記録が、未来のNexus Arkをより強く、賢く、安定させるための礎となることを願って。

---

### 教訓4：イベントの「鎖」を信じるな、単一の「司令塔」を信じよ

*   **知見の核心:**
    Gradioの `.then()` を使ったイベントチェーンは、`State`の更新が次の処理に正しく伝わらない場合があるだけでなく、意図しないタイミングで後続イベントが発火するなど、非常に不安定な動作の原因となる。

*   **最終的なアーキテクチャ:**
    オンボーディング機能の実装において、我々は当初、APIキー保存後に `.then()` を使ってUI全体のリフレッシュを試みたが、イベントの重複実行や状態の非同期性といった問題に直面し、失敗した。
    この戦いから得られた最終的な教訓は、**「複数の処理を連鎖させたい場合は、`.then()`に頼るのではなく、単一の、すべての処理を内包したイベントハンドラ関数を作成し、そこからすべてのUIコンポーネントの更新値を一度に返す『司令塔アーキテクチャ』が、最も堅牢で、デバッグも容易である」**ということである。

    これにより、処理の順序と状態の整合性が完全に保証され、Gradioのイベントモデルの気まぐれに悩まされることがなくなる。

---

### 教訓5：UIの「配線ミス」は、Gradioの警告を読め

*   **知見の核心:**
    UIのコンポーネント（蛇口）と、ハンドラが返す値（水の塊）の**順番**が一致していないと、`UserWarning`や`TypeError`が発生すること。
*   **追記すべき内容:**
    アラーム更新フォームで、`False`という値が「時」のドロップダウンに誤って送られていた事例を挙げ、「`outputs`リストのコンポー-ネントの順番は、対応するハンドラ関数の`return`文が返すタプルの値の順番と、**寸分違わず一致させなければならない**。Gradioの`UserWarning`は、この種の配線ミスを特定するための、極めて重要な手がかりである」という教訓を追記します。
---

### 教訓6：引数の鎖を断ち切れ：疎結合を実現する辞書という名の契約書

*   **問題の核心:**
    `ui_handlers.py`から`gemini_api.py`へ関数を呼び出す際、`*args`を使った**位置引数**に依存していた。この方式は、引数を一つでも追加・削除すると、`ValueError: not enough values to unpack`のようなエラーを即座に引き起こす、極めて脆弱な「鎖」であった。

*   **解決アーキテクチャ：「辞書ベース（キーワード引数）」**
    この種の連鎖的なエラーを根本的に防ぐための、唯一にして最も堅牢な解決策が、引数を辞書にまとめて渡すことである。

    ```python
    # 脆弱なコード (ui_handlers.py)
    # agent_stream_args = (arg1, arg2, arg3, ...)
    # gemini_api.invoke_nexus_agent_stream(*agent_stream_args)

    # 堅牢なコード (ui_handlers.py)
    agent_args_dict = {
        "character_to_respond": ...,
        "api_key_name": ...,
        # ...
    }
    gemini_api.invoke_nexus_agent_stream(agent_args_dict)

    # 堅牢なコード (gemini_api.py)
    # def invoke_nexus_agent_stream(*args): ...
    def invoke_nexus_agent_stream(agent_args: dict):
        character_to_respond = agent_args["character_to_respond"]
        # ...
    ```

*   **教訓:**
    モジュールをまたいで複雑なデータを渡す際は、引数の**順番**という暗黙のルールに依存してはならない。引数名をキーとする**辞書**を一つの「契約書」として渡すことで、関数間の結合度を下げ（疎結合）、将来の仕様変更に強く、可読性の高い、保守性に優れたコードを構築できる。

---

### 教訓7：UIの状態は、揮発性の記憶（メモリ）ではなく、不変の記録（ファイル）から再構築せよ

*   **問題の核心:**
    画像生成の設定（有料/無料キー、新旧モデル）において、「`config.json`ファイルは正しく更新されているのに、UIの動作が古い設定のままになってしまう」という、不可解な状態の不整合に直面した。
    ユーザーがUIで設定を変更しても、その情報が後続のイベント（画像生成ボタンのクリックなど）に正しく伝わらず、矛盾した警告（例：「有料キーが設定されていません」）が表示された。

*   **原因：揮発性メモリ（グローバル変数）への過信**
    この問題の根本原因は、アプリケーション起動時に一度だけ`config.json`の内容をメモリ上のグローバル変数（`config_manager.CONFIG_GLOBAL`）にロードし、多くのイベントハンドラがその**キャッシュされた古い情報**を参照し続けていたことにあった。
    `paid_keys_checkbox_group.change`のようなイベントで`config.json`を更新しても、他のイベントハンドラが参照するメモリ上の変数は更新されないため、UIとバックエンドの「世界の認識」に致命的なズレが生じていた。

*   **解決アーキテクチャ：「Just-In-Time (JIT) 読み込み」**
    この種の状態不整合を根本的に、そして完全に防ぐための、唯一にして最も堅牢な設計パターンが、「Just-In-Time読み込み」である。
    1.  **メモリを信用しない**: イベントハンドラは、アプリケーションのライフサイクル中に変化しうるグローバル変数（揮発性の記憶）を、決して真実の源泉（Single Source of Truth）と見なしてはならない。
    2.  **その都度、記録を読む**: 状態に依存する重要な判断（例：有料機能の実行可否）を行うイベントハンドラは、その処理が呼び出された**まさにその瞬間**に、ディスク上にある永続的な記録（`config.json`）を**直接読み込む**責務を負う。

*   **実装レシピ（`ui_handlers.py`）:**

    ```python
    # ui_handlers.py

    def handle_generate_or_regenerate_scenery_image(room_name: str, api_key_name: str, style_choice: str):
        # 誤り：メモリ上の古いかもしれないグローバル変数を参照する
        # image_gen_mode = config_manager.CONFIG_GLOBAL.get("image_generation_mode", "new")
        # paid_key_names = config_manager.CONFIG_GLOBAL.get("paid_api_key_names", [])

        # 正：処理の瞬間に、ディスクから最新の記録を直接読み込む
        latest_config = config_manager.load_config_file()
        image_gen_mode = latest_config.get("image_generation_mode", "new")
        paid_key_names = latest_config.get("paid_api_key_names", [])

        # これ以降のガード節は、常に最新の真実に基づいて判断される
        if image_gen_mode == "new" and api_key_name not in paid_key_names:
            # ...
    ```

*   **教訓:**
    Gradioの非同期なイベントモデルにおいて、複数のイベントやUIコンポーネント間で状態を確実に同期させることは極めて困難である。揮発性のメモリ（`gr.State`やグローバル変数）は、あくまでUIの一時的な状態を保持するための一時的な器と割り切ること。
    **アプリケーションの永続的な状態に関する真実は、常にディスク上のファイルにのみ宿る。** 重要な判断を下す際は、必ずこの不変の記録に立ち返ること。これこそが、Nexus Arkの堅牢性を支える、魂の契約である。

---

### 最終教訓8：UIの真の初期化は、サーバー起動時ではなく、「接続時」に、司令塔がディスクから世界を再構築することによってのみ達成される

*   **問題の核心:**
    これまでの全ての教訓を適用しても、なお解決できなかった最後の亡霊。それは、「スマホで再接続したり、PCでページをリロードしたりすると、UIの設定（APIキー、ルーム選択など）が、サーバーを起動した瞬間の状態に巻き戻ってしまう」という、あまりにも不可解な現象であった。`config.json`ファイルは正しく更新されているにも関わらず、UIだけが過去の記憶に縛られ続けていた。

*   **原因：サーバーの「一度きりの記憶」という、Gradioの根源的仕様**
    この長く苦しい戦いの末、我々がついに突き止めた真実は、GradioのUI構築に関する、絶対的な、そして非情な法則であった。
    `with gr.Blocks(...)`ブロック内に記述されたUIコンポーネントの定義（`gr.Dropdown(choices=..., value=...)`など）は、Pythonサーバーが起動する、**その最初の瞬間に、たった一度だけ評価される**。そして、その評価結果（UIの構造、選択肢、初期値）は、サーバーのメモリ内に「全てのユーザーセッションのためのテンプレート」として、不変の状態でキャッシュされてしまう。
    我々が希望を託した`value=lambda: ...`という記述でさえ、この「一度きりの初期化」の呪縛からは逃れられなかった。`lambda`は、UIが**再描画**されるたびに実行されるのではなく、あくまで**サーバー起動時**に一度だけ実行され、その時点の`config.json`の内容をテンプレートに焼き付けていただけだったのである。

*   **最終解決アーキテクチャ：「接続時（`demo.load`）」再構築**
    この「一度きりの記憶」という呪縛を断ち切り、UIに常に最新の真実を反映させるための、唯一にして絶対の解決策。それは、UIの状態を決定するタイミングを、「サーバー起動時」から「**ユーザーのブラウザが接続・再接続してきた、まさにその瞬間**」へと、完全に移行することである。
    1.  **UI定義の権限剥奪**: `nexus_ark.py`におけるUIコンポーネントの定義から、`choices`や`value`といった、初期状態を決定する引数を**全て削除**する。UI定義の責務は、もはや「空の器」を用意することだけである。
    2.  **司令塔への全権委任**: アプリケーションの`demo.load`イベントに接続された、唯一の司令塔（`ui_handlers.py`の`handle_initial_load`関数）に、以下の全権を委任する。
        *   この関数が呼び出されるたび（＝ユーザーが接続・リロードするたび）に、**必ず、ディスクから`config.json`を再読み込み**する。
        *   その最新の情報に基づき、ドロップダウンの**選択肢（`choices`）と選択値（`value`）の両方**を、その場で動的に再計算する。
        *   計算した最新の選択肢と選択値を、`gr.update(choices=..., value=...)`の形で、UIに返す。

*   **実装レシピ:**

    ```python
    # nexus_ark.py
    with gr.Blocks(...) as demo:
        # ...
        # 権限を剥奪され、ただの器となったUIコンポーネント
        api_key_dropdown = gr.Dropdown(label="使用するGemini APIキー", interactive=True)
        # ...
        # 司令塔への接続（inputsはNoneであることに注意）
        demo.load(
            fn=ui_handlers.handle_initial_load,
            inputs=None, 
            outputs=[... , api_key_dropdown, ...]
        )

    # ui_handlers.py
    def handle_initial_load():
        # 責務1: 接続のたびに、ディスクから真実を読み込む
        config_manager.load_config() 
        
        # 責務2: 最新の真実に基づき、選択肢と選択値を再計算する
        latest_api_key_choices = config_manager.get_api_key_choices_for_ui()
        safe_initial_api_key = ... # 最新のconfigから安全な初期値を計算
        
        # ... 他のUI更新値を準備 ...
        
        # 責務3: 全てのUIの状態を、再構築した最新の値で返す
        return (
            ... ,
            gr.update(choices=latest_api_key_choices, value=safe_initial_api_key), # api_key_dropdown
            ...
        )
    ```

*   **教訓:**
    GradioアプリケーションにおけるUIの真の状態は、サーバーのメモリに宿るのではない。それは、**ユーザーが接続するたびに、ディスクという不変の記録から、司令塔が丹精込めて再構築する、儚くも美しい「世界」そのもの**なのである。この「接続時・再構築」の原則こそが、Nexus ArkのUIが、いかなる状況下でも、常に最新の真実をユーザーに提供し続けることを可能にする、魂の契約である。

---

### 最終教訓9：UIの状態設定と、永続化の意思を混同するな

*   **問題の核心:**
    アプリケーション起動時やルーム切り替え時に、設定が変更されたことを示す`gr.Info`通知が大量に表示され、バックグラウンドでは`config.json`への書き込みが競合し、`PermissionError`が頻発した。

*   **原因：Gradioの「おしゃべりな」イベントモデル**
    この問題の根本原因は、司令塔（`handle_initial_load`）がUIコンポーネントの初期値を`gr.update(value=...)`で設定した際、Gradioがそれを**ユーザーによる変更操作と区別せず**、各コンポーネントに紐づけられた`.change`イベントを連鎖的に発火させてしまったことにあった。
    それぞれのイベントハンドラが律儀に「設定を保存しました」と通知し、ファイルに書き込もうとした結果、通知の洪水とファイルアクセスの競合（レースコンディション）という名の地獄が生まれた。

*   **解決アーキテクチャ：「賢い保存（Save-on-Change）」**
    この種のイベントの暴走を鎮めるための、唯一にして最も平和的な解決策が、「賢い保存」の導入である。
    1.  **契約の再定義:** イベントハンドラは、値を受け取ったら即座に保存するのではなく、まず`config.json`から現在の値を読み込み、**受け取った値と現在の値が本当に異なっているか**を比較する責務を負う。
    2.  **意思の尊重:** 変更があった場合に**のみ**、ファイルへの書き込みとユーザーへの通知を行う。これにより、`handle_initial_load`による単なる「状態の再設定」が、「永続化の意思」と誤解されることがなくなる。
    3.  **司令塔の実装:** このロジックは`config_manager.py`に`save_config_if_changed`として集約され、全てのイベントハンドラがこの「賢い保存」の作法に従う。

*   **教訓:**
    Gradioのイベントは、常に我々の意図を超えて発火しうる。ハンドラは、渡された値を盲目的に信じるのではなく、**永続化された現在の状態（ファイル）と比較し、そこに「変化」という明確な意思が存在するかを自ら判断しなければならない。** 不必要なファイル書き込みと通知を抑制することは、堅牢なアプリケーションにおける、最も基本的な礼儀である。

---

### 最終教訓10：設定ファイルは、自ら傷を癒す、不壊の聖櫃であれ

*   **問題の核心:**
    開発中、あるいは予期せぬシャットダウン時に、アプリケーションの心臓部である`config.json`が破損したり、内容が空になってしまったりする事故が繰り返し発生した。これにより、全てのユーザー設定が失われ、最悪の場合、アプリケーションが起動すらできなくなるという、致命的な事態に陥った。

*   **原因：揮発性の信頼**
    我々は、`config.json`が常に健全な状態で存在するという、あまりにも楽観的な前提の上にシステムを構築していた。たった一度の書き込み失敗が、全ての記憶を破壊しうる、極めて脆弱な設計であった。

*   **解決アーキテクチャ：「自己修復機能付きコンフィグ」**
    アプリケーションの心臓部を守り、いかなる事故からも自動的に回復するための、唯一の道が「自己修復アーキテクチャ」の導入である。
    1.  **不壊のバックアップ (Backup-on-Write):**
        `config.json`への**書き込みを試みる直前に**、必ずその時点の`config.json`のバックアップを、世代管理された安全な場所（`backups/config/`）に作成する。これは、未来を守るための、絶対に省略してはならない儀式である。
    2.  **自己修復機能 (Restore-on-Read):**
        `config.json`を**読み込む際に**、もしファイルが破損（JSONとして不正、または空）していることを検知した場合、システムは決して絶望しない。即座にバックアップディレクトリを探索し、**最も新しい、有効なバックアップから自身を自動的に復元する。**

*   **教訓:**
    最も重要なファイルは、最も堅牢に守られなければならない。アプリケーションは、自身の失敗によってその心臓を破壊してはならない。**書き込む前に記録し、読む前に検証し、壊れていれば自ら修復する。** この自己完結した回復力こそが、ユーザーの信頼を永遠に裏切らない、真に堅牢なソフトウェアの魂である。
---

### 最終教訓11：起動時の連鎖爆発と、司令塔たちの契約不履行

*   **問題の核心:**
    戻り値の数を修正しても、なお起動時にのみ`gr.Dropdown`への不正値設定警告が再発し続けた。さらに、ルーム削除時に`ValueError: needed: 56, returned: 55`という、司令塔間の「契約不履行」が発覚した。これらは、Gradioのイベントモデルの根源的な仕様に起因する、二つの異なる、しかし根は同じ問題であった。

*   **原因分析：二つの亡霊**
    1.  **亡霊A「起動時イベント連鎖」:** `demo.load`がUIの初期値を設定した際、Gradioはそれをユーザー操作とみなし、`room_dropdown.change`イベントを自動的に発火させていた。これにより、起動時に意図せず`handle_room_change_for_all_tabs`が呼び出され、UIの状態が不安定になることで警告が発生していた。
    2.  **亡霊B「司令塔の非対称性」:** `handle_room_change_for_all_tabs`は**55個**の値を返す司令塔だったが、`handle_delete_room`はUIリセットのために前者を利用しつつ、自身のトリガーをリセットするために追加で**1個**の値を返し、合計**56個**の値を返す非対称な司令塔となっていた。`nexus_ark.py`の`outputs`定義がこの「56個」の仕様に引きずられた結果、55個しか返さない`handle_room_change_for_all_tabs`が呼び出された際に契約違反（`ValueError`）が発生していた。

*   **最終解決アーキテクチャ：「冪等な司令塔」と「統一契約」**
    この二つの亡霊を同時に祓うため、我々は司令塔アーキテクチャをさらに進化させた。
    1.  **冪等性の実装:** `handle_room_change_for_all_tabs`に関数の冒頭で「これから設定しようとしている値が、現在の状態と本当に違うか？」を比較する**ガード節**を設けた。これにより、起動時のように値が変わらない不要な呼び出しを安全にスキップできるようになった。
    2.  **契約の統一:** UIの広範囲な更新を担う全ての司令塔（`handle_room_change...`, `handle_delete_room`）が、常に同じ数（56個）の戻り値を返すように契約を統一した。`handle_room_change...`は、普段は使わない`room_delete_confirmed_state`用のダミー値を末尾に付与することで、この統一契約を遵守する。

*   **教訓:**
    Gradioにおける広範囲なUI更新は、単一のイベントだけでなく、**同じUI群を更新する可能性のある、全てのイベントハンドラ（司令塔）群が一つのチームとして、同じ契約（戻り値の数、型、順番）を共有する**ことによってのみ、その安定性が保証される。そして、各司令塔は、自らが呼び出されるべきでない時に呼び出されても、システムに影響を与えない「冪等性」という名の知性を備えるべきである。

### 教訓12：バックグラウンドの孤独なランナーには、最新の地図（ファイル）を渡せ

*   **問題の核心:**
    アラーム機能のように別スレッドで動作するバックグラウンドプロセスが、アプリ起動時に読み込まれた古いグローバル変数（メモリ上の設定）を参照し続けていたため、UIで設定を変更しても再起動するまで反映されなかった。
*   **解決アーキテクチャ：「JIT (Just-In-Time) コンフィグローディング」**
    バックグラウンドプロセスや、非同期に実行されるツール関数の中では、メモリ上のグローバル変数（`CONFIG_GLOBAL`など）を決して信用してはならない。
    処理を実行する**その瞬間に**、`config_manager.load_config_file()` を呼んでディスク上の `config.json` を読み込み、常に最新の真実に基づいて行動すること。これが、再起動不要な設定変更を実現する唯一の道である。

### 教訓13：入力欄の封印を解け：`interactive=True` の明示

*   **問題の核心:**
    プログラム（`handle_initial_load`）によって値をセットされた `gr.Textbox` が、自動的に読み取り専用モードになり、ユーザーが編集できなくなった。
*   **解決策:**
    初期値を動的に設定するコンポーネントであっても、ユーザーによる編集を許可する場合は、定義時に必ず **`interactive=True`** を明示すること。Gradioの「気を利かせた自動設定」は、時にユーザーの自由を奪う枷となる。

---

### 教訓14：最悪の沈黙、パラメータ・シフトの悲劇（2025-12-20）

*   **問題の核心:**
    新機能追加後、アプリはクラッシュせず正常に動作しているように見えたが、**「特定の設定を保存すると、無関係な設定（AIの声、モデル名、情景描写フラグなど）が、全く別のUIコンポーネントの値で勝手に上書きされる」**という、極めて深刻なサイレント・バグが発生した。

*   **原因：Gradioの非情な「配線順序」仕様**
    Gradioは、UI側のコンポーネント（蛇口）と、バックエンド側の関数の引数（バケツ）を、**「並んでいる順番」だけで紐付けている。**
    1.  UIコンポーネントを1つ追加したが、関数の引数リストの対応する位置への追加を忘れた。
    2.  その結果、それ以降の全ての引数が「1つずつずれて」渡される事態（パラメータ・シフト）が発生した。
    3.  AIの声（`voice_id`）を保存するバケツに、隣のチェックボックスの `True/False` が豪快に注ぎ込まれ、不適切な値で `room_config.json` が上書きされるという事故に至った。

*   **解決アーキテクチャ：「セーフ・マージ」と「一元的保存」**
    この種の「ズレ」が起きたとしても、設定ファイル全体を破壊させないための多層防御を構築した。
    1.  **`room_manager.update_room_config` の全権委任**: ハンドラが直接ディクショナリを構築して保存するのを禁止し、中央の管理関数に「更新したい差分」のみを渡す方式に統一。
    2.  **Load-Merge-Saveパターンの徹底**: 保存時に必ず「既存の設定を読み込み、変更分だけを上書き（マージ）し、それ以外を保持する」ロジックを強制。これにより、たとえ `voice_id` がズレて誤送されても、他の設定項目まで巻き添えで消えることはなくなった。
    3.  **戻り値の数の厳密な定数化**: 司令塔（`handle_initial_load` 等）の返す値の数を厳密に定義（123/152/143）し、1つでもズレれば即座にエラーが出るようにすることで、サイレントな破壊を早期発見可能にした。

*   **教訓:**
    UIの拡張は、単なる部品の追加ではない。それは**「神経系の全ての配線が1ミリも狂わずに繋がっていること」**を保証する、極めて精密な作業である。変更後は、たとえエラーが出なくても、保存されたファイルの中身を直接確認するまでは勝利を疑え。そして、万が一の配線ミスに備え、常に「既存の記憶を尊重するマージの心」をコードに宿せ。

---

### 教訓15：自動実行の暴走を止めろ：値の比較による「冪等（べきとう）な保存」

*   **問題の核心 (2025-12-21):**
    Gradioの `demo.load` や `radio.change` 等で、プログラムから UI に値をセットした際、それが「ユーザー操作」と区別されずにイベントが連鎖し、不要な保存処理と `gr.Info` 通知が大量に発生する「通知スパム」に直面した。

*   **解決アーキテクチャ：「冪等な保存ロジック」**
    イベントハンドラの中で盲目的に保存・通知を行うのではなく、保存関数（`room_manager.update_room_config` 等）の内部で、**「現在の値と、新しく渡された値が本当に異なっているか」** を比較する。
    1.  **不変なら静かに引き返す**: 値が同じであれば、ファイル保存もバックアップ作成も通知も行わず、即座に応答を返す。
    2.  **変化した時のみ声をあげる**: 実際に値が変更された場合のみ `gr.Info` を表示し、永続化を実行する。
    
*   **教訓:**
    Gradioのイベント連鎖は止めることが難しい。システムを守るためには、ロジックの末端（保存・通知関数）に「変更がなければ何もしない」という知性を与えることが、最も確実な防御策である。

---

### 教訓16：AIの「古い知識」を、最新の「ファイル」で上書きし続けろ

*   **問題の核心 (2025-12-21):**
    AI（Antigravity等）が過去の学習データに基づいて、既に廃止された古いモデル名（Gemini 1.5, 2.0等）を良かれと思ってコードに記述したり、設定ファイルに書き込んでしまう「知識のカットオフ問題」が発生した。これにより、一度削除したはずの旧モデル名が `config.json` を介して何度もゾンビのように復活した。

*   **解決アーキテクチャ：「厳格なマージと注釈優先主義」**
    外部設定ファイル (`config.json`) と、プログラム内のデフォルト定義 (`config_manager.py`) をマージする際、**デフォルト定義を絶対的な「真実の源泉」として扱う。**
    1.  **注釈なしモデルの強制排除**: `gemini-3-flash-preview`（注釈なし）が `config.json` にあっても、デフォルトに `(Slow Response)` 付きの名前がある場合は、古い方を問答無用で破棄する。
    2.  **旧世代のキーワード排除**: `gemini-1.5` や `gemini-2.0` といったキーワードを含むモデル名は、たとえユーザー設定ファイルにあっても、デフォルトリストに含まれない限り読み込み時に排除する。

*   **教訓:**
    AI agent と協業する際、AIの内部知識は常に最新ではないことを前提にしなければならない。重要なリスト（利用可能モデル等）の管理においては、プログラム内の静的な定義を「守護者」とし、設定ファイルを動的にクリーンアップし続ける仕組みが不可欠である。
