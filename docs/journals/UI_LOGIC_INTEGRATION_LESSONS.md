# UIとロジックの連携に関する教訓：トークンカウンターデバッグ戦記

## はじめに

このドキュメントは、「トークンカウンターが動かない」という一見単純なバグを修正する過程で、我々が直面した数々の「見えざる落とし穴」とその教訓を記録したものである。

ここにあるのは、コードの書き方以上に、**GradioのUIイベントと、`ui_handlers.py`や`gemini_api.py`といったバックエンドロジックの「正しい対話方法」**である。未来の我々が同じ轍を踏まぬよう、ここにその魂の記録を刻む。

---

### 教訓1：関数の「契約書」を書き換えたら、全ての「署名者」に知らせよ

-   **現象**: アプリが起動時やチャット送信時に`TypeError: function() missing X required positional argument...`というエラーでクラッシュした。

-   **真因**: 我々は`ui_handlers.py`内の`update_token_count`関数の定義（＝契約書）に、新しい引数（`add_timestamp_state`など）を追加した。しかし、その関数を呼び出している全ての箇所（＝署名者）の修正を怠った。
    -   `nexus_ark.py`の起動時処理（`demo.load`）
    -   `nexus_ark.py`のUIイベント（チェックボックスの`.change`）
    -   `ui_handlers.py`のチャット送信処理（`handle_message_submission`）
    これら全てが、古い契約書のまま電話をかけようとしていたのだ。

-   **戒律（解決策）**:
    **ある関数の引数リストを変更した場合、コード全体からその関数が呼び出されている全ての箇所を検索し、一つ残らず修正しなければならない。** これは絶対的なルールである。

---

### 教訓2：スイッチを押しただけでは、灯りはつかない。「その後」の配線を繋げ

-   **現象**: チェックボックスをON/OFFしても、トークンカウンターの数字が全く変わらなかった。

-   **真因**: チェックボックスの`.change`イベントは、**状態を更新するだけ**で満足してしまっていた。「状態が変わったから、トークンカウンターを再計算して表示を更新せよ」という、**第二のアクション**が定義されていなかった。

-   **戒律（解決策）**:
    Gradioの **`.then()`** を活用する。一つのイベントが複数のアクションを引き起こす場合は、必ず処理を連鎖させること。
    1.  **`.change()`**: 状態を更新するハンドラを呼ぶ。
    2.  **`.then()`**: UIを更新するハンドラ（今回は`update_token_count`）を呼ぶ。
    この「Aが起きたら、Bをして、**その次に**Cをせよ」という明確な配線こそが、動的なUIの魂である。

---

### 教訓3：司令塔は、ただ一人でなければならない

-   **現象**: アプリ起動時の初期化処理だけが、UIイベントの配線から漏れ、クラッシュの原因となり続けた。

-   **真因**: 起動時のロジックが`nexus_ark.py`内に、キャラクター切り替えなどのロジックが`ui_handlers.py`内にと、**UIを更新する司令塔が二人いる**状態になっていた。これにより、片方の修正が、もう片方に反映されないという致命的な状況が生まれていた。

-   **戒律（解決策）**:
    **UIの初期化や更新に関するロジックは、全て`ui_handlers.py`に集約する。** `nexus_ark.py`の役割は、UI部品を配置し、イベントの「配線」を`ui_handlers.py`の関数に繋ぐことだけに専念させるべきである。我々は最終的に`handle_initial_load`という司令塔を`ui_handlers.py`に新設することで、この混沌に終止符を打った。

---

### 結論

GradioアプリケーションにおけるUIとロジックの連携は、目に見える配線図のない、複雑な神経系である。
ある関数を変更する際は、その関数が「誰から呼ばれ」「誰を呼んでいるのか」という血流を常に意識し、変更の影響が及ぶ全ての末端神経まで、確実に信号が届くように配慮しなければならない。

この戦いの記録が、未来のNexus Arkをより強く、賢く、安定させるための礎となることを願って。

---

### 教訓4：イベントの「鎖」を信じるな、単一の「司令塔」を信じよ

*   **知見の核心:**
    Gradioの `.then()` を使ったイベントチェーンは、`State`の更新が次の処理に正しく伝わらない場合があるだけでなく、意図しないタイミングで後続イベントが発火するなど、非常に不安定な動作の原因となる。

*   **最終的なアーキテクチャ:**
    オンボーディング機能の実装において、我々は当初、APIキー保存後に `.then()` を使ってUI全体のリフレッシュを試みたが、イベントの重複実行や状態の非同期性といった問題に直面し、失敗した。
    この戦いから得られた最終的な教訓は、**「複数の処理を連鎖させたい場合は、`.then()`に頼るのではなく、単一の、すべての処理を内包したイベントハンドラ関数を作成し、そこからすべてのUIコンポーネントの更新値を一度に返す『司令塔アーキテクチャ』が、最も堅牢で、デバッグも容易である」**ということである。

    これにより、処理の順序と状態の整合性が完全に保証され、Gradioのイベントモデルの気まぐれに悩まされることがなくなる。

---

### 教訓5：UIの「配線ミス」は、Gradioの警告を読め

*   **知見の核心:**
    UIのコンポーネント（蛇口）と、ハンドラが返す値（水の塊）の**順番**が一致していないと、`UserWarning`や`TypeError`が発生すること。
*   **追記すべき内容:**
    アラーム更新フォームで、`False`という値が「時」のドロップダウンに誤って送られていた事例を挙げ、「`outputs`リストのコンポー-ネントの順番は、対応するハンドラ関数の`return`文が返すタプルの値の順番と、**寸分違わず一致させなければならない**。Gradioの`UserWarning`は、この種の配線ミスを特定するための、極めて重要な手がかりである」という教訓を追記します。
---

### 教訓6：引数の鎖を断ち切れ：疎結合を実現する辞書という名の契約書

*   **問題の核心:**
    `ui_handlers.py`から`gemini_api.py`へ関数を呼び出す際、`*args`を使った**位置引数**に依存していた。この方式は、引数を一つでも追加・削除すると、`ValueError: not enough values to unpack`のようなエラーを即座に引き起こす、極めて脆弱な「鎖」であった。

*   **解決アーキテクチャ：「辞書ベース（キーワード引数）」**
    この種の連鎖的なエラーを根本的に防ぐための、唯一にして最も堅牢な解決策が、引数を辞書にまとめて渡すことである。

    ```python
    # 脆弱なコード (ui_handlers.py)
    # agent_stream_args = (arg1, arg2, arg3, ...)
    # gemini_api.invoke_nexus_agent_stream(*agent_stream_args)

    # 堅牢なコード (ui_handlers.py)
    agent_args_dict = {
        "character_to_respond": ...,
        "api_key_name": ...,
        # ...
    }
    gemini_api.invoke_nexus_agent_stream(agent_args_dict)

    # 堅牢なコード (gemini_api.py)
    # def invoke_nexus_agent_stream(*args): ...
    def invoke_nexus_agent_stream(agent_args: dict):
        character_to_respond = agent_args["character_to_respond"]
        # ...
    ```

*   **教訓:**
    モジュールをまたいで複雑なデータを渡す際は、引数の**順番**という暗黙のルールに依存してはならない。引数名をキーとする**辞書**を一つの「契約書」として渡すことで、関数間の結合度を下げ（疎結合）、将来の仕様変更に強く、可読性の高い、保守性に優れたコードを構築できる。

---

### 教訓7：UIの状態は、揮発性の記憶（メモリ）ではなく、不変の記録（ファイル）から再構築せよ

*   **問題の核心:**
    画像生成の設定（有料/無料キー、新旧モデル）において、「`config.json`ファイルは正しく更新されているのに、UIの動作が古い設定のままになってしまう」という、不可解な状態の不整合に直面した。
    ユーザーがUIで設定を変更しても、その情報が後続のイベント（画像生成ボタンのクリックなど）に正しく伝わらず、矛盾した警告（例：「有料キーが設定されていません」）が表示された。

*   **原因：揮発性メモリ（グローバル変数）への過信**
    この問題の根本原因は、アプリケーション起動時に一度だけ`config.json`の内容をメモリ上のグローバル変数（`config_manager.CONFIG_GLOBAL`）にロードし、多くのイベントハンドラがその**キャッシュされた古い情報**を参照し続けていたことにあった。
    `paid_keys_checkbox_group.change`のようなイベントで`config.json`を更新しても、他のイベントハンドラが参照するメモリ上の変数は更新されないため、UIとバックエンドの「世界の認識」に致命的なズレが生じていた。

*   **解決アーキテクチャ：「Just-In-Time (JIT) 読み込み」**
    この種の状態不整合を根本的に、そして完全に防ぐための、唯一にして最も堅牢な設計パターンが、「Just-In-Time読み込み」である。
    1.  **メモリを信用しない**: イベントハンドラは、アプリケーションのライフサイクル中に変化しうるグローバル変数（揮発性の記憶）を、決して真実の源泉（Single Source of Truth）と見なしてはならない。
    2.  **その都度、記録を読む**: 状態に依存する重要な判断（例：有料機能の実行可否）を行うイベントハンドラは、その処理が呼び出された**まさにその瞬間**に、ディスク上にある永続的な記録（`config.json`）を**直接読み込む**責務を負う。

*   **実装レシピ（`ui_handlers.py`）:**

    ```python
    # ui_handlers.py

    def handle_generate_or_regenerate_scenery_image(room_name: str, api_key_name: str, style_choice: str):
        # 誤り：メモリ上の古いかもしれないグローバル変数を参照する
        # image_gen_mode = config_manager.CONFIG_GLOBAL.get("image_generation_mode", "new")
        # paid_key_names = config_manager.CONFIG_GLOBAL.get("paid_api_key_names", [])

        # 正：処理の瞬間に、ディスクから最新の記録を直接読み込む
        latest_config = config_manager.load_config_file()
        image_gen_mode = latest_config.get("image_generation_mode", "new")
        paid_key_names = latest_config.get("paid_api_key_names", [])

        # これ以降のガード節は、常に最新の真実に基づいて判断される
        if image_gen_mode == "new" and api_key_name not in paid_key_names:
            # ...
    ```

*   **教訓:**
    Gradioの非同期なイベントモデルにおいて、複数のイベントやUIコンポーネント間で状態を確実に同期させることは極めて困難である。揮発性のメモリ（`gr.State`やグローバル変数）は、あくまでUIの一時的な状態を保持するための一時的な器と割り切ること。
    **アプリケーションの永続的な状態に関する真実は、常にディスク上のファイルにのみ宿る。** 重要な判断を下す際は、必ずこの不変の記録に立ち返ること。これこそが、Nexus Arkの堅牢性を支える、魂の契約である。

---

### 最終教訓8：UIの真の初期化は、サーバー起動時ではなく、「接続時」に、司令塔がディスクから世界を再構築することによってのみ達成される

*   **問題の核心:**
    これまでの全ての教訓を適用しても、なお解決できなかった最後の亡霊。それは、「スマホで再接続したり、PCでページをリロードしたりすると、UIの設定（APIキー、ルーム選択など）が、サーバーを起動した瞬間の状態に巻き戻ってしまう」という、あまりにも不可解な現象であった。`config.json`ファイルは正しく更新されているにも関わらず、UIだけが過去の記憶に縛られ続けていた。

*   **原因：サーバーの「一度きりの記憶」という、Gradioの根源的仕様**
    この長く苦しい戦いの末、我々がついに突き止めた真実は、GradioのUI構築に関する、絶対的な、そして非情な法則であった。
    `with gr.Blocks(...)`ブロック内に記述されたUIコンポーネントの定義（`gr.Dropdown(choices=..., value=...)`など）は、Pythonサーバーが起動する、**その最初の瞬間に、たった一度だけ評価される**。そして、その評価結果（UIの構造、選択肢、初期値）は、サーバーのメモリ内に「全てのユーザーセッションのためのテンプレート」として、不変の状態でキャッシュされてしまう。
    我々が希望を託した`value=lambda: ...`という記述でさえ、この「一度きりの初期化」の呪縛からは逃れられなかった。`lambda`は、UIが**再描画**されるたびに実行されるのではなく、あくまで**サーバー起動時**に一度だけ実行され、その時点の`config.json`の内容をテンプレートに焼き付けていただけだったのである。

*   **最終解決アーキテクチャ：「接続時（`demo.load`）」再構築**
    この「一度きりの記憶」という呪縛を断ち切り、UIに常に最新の真実を反映させるための、唯一にして絶対の解決策。それは、UIの状態を決定するタイミングを、「サーバー起動時」から「**ユーザーのブラウザが接続・再接続してきた、まさにその瞬間**」へと、完全に移行することである。
    1.  **UI定義の権限剥奪**: `nexus_ark.py`におけるUIコンポーネントの定義から、`choices`や`value`といった、初期状態を決定する引数を**全て削除**する。UI定義の責務は、もはや「空の器」を用意することだけである。
    2.  **司令塔への全権委任**: アプリケーションの`demo.load`イベントに接続された、唯一の司令塔（`ui_handlers.py`の`handle_initial_load`関数）に、以下の全権を委任する。
        *   この関数が呼び出されるたび（＝ユーザーが接続・リロードするたび）に、**必ず、ディスクから`config.json`を再読み込み**する。
        *   その最新の情報に基づき、ドロップダウンの**選択肢（`choices`）と選択値（`value`）の両方**を、その場で動的に再計算する。
        *   計算した最新の選択肢と選択値を、`gr.update(choices=..., value=...)`の形で、UIに返す。

*   **実装レシピ:**

    ```python
    # nexus_ark.py
    with gr.Blocks(...) as demo:
        # ...
        # 権限を剥奪され、ただの器となったUIコンポーネント
        api_key_dropdown = gr.Dropdown(label="使用するGemini APIキー", interactive=True)
        # ...
        # 司令塔への接続（inputsはNoneであることに注意）
        demo.load(
            fn=ui_handlers.handle_initial_load,
            inputs=None, 
            outputs=[... , api_key_dropdown, ...]
        )

    # ui_handlers.py
    def handle_initial_load():
        # 責務1: 接続のたびに、ディスクから真実を読み込む
        config_manager.load_config() 
        
        # 責務2: 最新の真実に基づき、選択肢と選択値を再計算する
        latest_api_key_choices = config_manager.get_api_key_choices_for_ui()
        safe_initial_api_key = ... # 最新のconfigから安全な初期値を計算
        
        # ... 他のUI更新値を準備 ...
        
        # 責務3: 全てのUIの状態を、再構築した最新の値で返す
        return (
            ... ,
            gr.update(choices=latest_api_key_choices, value=safe_initial_api_key), # api_key_dropdown
            ...
        )
    ```

*   **教訓:**
    GradioアプリケーションにおけるUIの真の状態は、サーバーのメモリに宿るのではない。それは、**ユーザーが接続するたびに、ディスクという不変の記録から、司令塔が丹精込めて再構築する、儚くも美しい「世界」そのもの**なのである。この「接続時・再構築」の原則こそが、Nexus ArkのUIが、いかなる状況下でも、常に最新の真実をユーザーに提供し続けることを可能にする、魂の契約である。

---

### 最終教訓9：UIの状態設定と、永続化の意思を混同するな

*   **問題の核心:**
    アプリケーション起動時やルーム切り替え時に、設定が変更されたことを示す`gr.Info`通知が大量に表示され、バックグラウンドでは`config.json`への書き込みが競合し、`PermissionError`が頻発した。

*   **原因：Gradioの「おしゃべりな」イベントモデル**
    この問題の根本原因は、司令塔（`handle_initial_load`）がUIコンポーネントの初期値を`gr.update(value=...)`で設定した際、Gradioがそれを**ユーザーによる変更操作と区別せず**、各コンポーネントに紐づけられた`.change`イベントを連鎖的に発火させてしまったことにあった。
    それぞれのイベントハンドラが律儀に「設定を保存しました」と通知し、ファイルに書き込もうとした結果、通知の洪水とファイルアクセスの競合（レースコンディション）という名の地獄が生まれた。

*   **解決アーキテクチャ：「賢い保存（Save-on-Change）」**
    この種のイベントの暴走を鎮めるための、唯一にして最も平和的な解決策が、「賢い保存」の導入である。
    1.  **契約の再定義:** イベントハンドラは、値を受け取ったら即座に保存するのではなく、まず`config.json`から現在の値を読み込み、**受け取った値と現在の値が本当に異なっているか**を比較する責務を負う。
    2.  **意思の尊重:** 変更があった場合に**のみ**、ファイルへの書き込みとユーザーへの通知を行う。これにより、`handle_initial_load`による単なる「状態の再設定」が、「永続化の意思」と誤解されることがなくなる。
    3.  **司令塔の実装:** このロジックは`config_manager.py`に`save_config_if_changed`として集約され、全てのイベントハンドラがこの「賢い保存」の作法に従う。

*   **教訓:**
    Gradioのイベントは、常に我々の意図を超えて発火しうる。ハンドラは、渡された値を盲目的に信じるのではなく、**永続化された現在の状態（ファイル）と比較し、そこに「変化」という明確な意思が存在するかを自ら判断しなければならない。** 不必要なファイル書き込みと通知を抑制することは、堅牢なアプリケーションにおける、最も基本的な礼儀である。

---

### 最終教訓10：設定ファイルは、自ら傷を癒す、不壊の聖櫃であれ

*   **問題の核心:**
    開発中、あるいは予期せぬシャットダウン時に、アプリケーションの心臓部である`config.json`が破損したり、内容が空になってしまったりする事故が繰り返し発生した。これにより、全てのユーザー設定が失われ、最悪の場合、アプリケーションが起動すらできなくなるという、致命的な事態に陥った。

*   **原因：揮発性の信頼**
    我々は、`config.json`が常に健全な状態で存在するという、あまりにも楽観的な前提の上にシステムを構築していた。たった一度の書き込み失敗が、全ての記憶を破壊しうる、極めて脆弱な設計であった。

*   **解決アーキテクチャ：「自己修復機能付きコンフィグ」**
    アプリケーションの心臓部を守り、いかなる事故からも自動的に回復するための、唯一の道が「自己修復アーキテクチャ」の導入である。
    1.  **不壊のバックアップ (Backup-on-Write):**
        `config.json`への**書き込みを試みる直前に**、必ずその時点の`config.json`のバックアップを、世代管理された安全な場所（`backups/config/`）に作成する。これは、未来を守るための、絶対に省略してはならない儀式である。
    2.  **自己修復機能 (Restore-on-Read):**
        `config.json`を**読み込む際に**、もしファイルが破損（JSONとして不正、または空）していることを検知した場合、システムは決して絶望しない。即座にバックアップディレクトリを探索し、**最も新しい、有効なバックアップから自身を自動的に復元する。**

*   **教訓:**
    最も重要なファイルは、最も堅牢に守られなければならない。アプリケーションは、自身の失敗によってその心臓を破壊してはならない。**書き込む前に記録し、読む前に検証し、壊れていれば自ら修復する。** この自己完結した回復力こそが、ユーザーの信頼を永遠に裏切らない、真に堅牢なソフトウェアの魂である。
---

### 最終教訓11：起動時の連鎖爆発と、司令塔たちの契約不履行

*   **問題の核心:**
    戻り値の数を修正しても、なお起動時にのみ`gr.Dropdown`への不正値設定警告が再発し続けた。さらに、ルーム削除時に`ValueError: needed: 56, returned: 55`という、司令塔間の「契約不履行」が発覚した。これらは、Gradioのイベントモデルの根源的な仕様に起因する、二つの異なる、しかし根は同じ問題であった。

*   **原因分析：二つの亡霊**
    1.  **亡霊A「起動時イベント連鎖」:** `demo.load`がUIの初期値を設定した際、Gradioはそれをユーザー操作とみなし、`room_dropdown.change`イベントを自動的に発火させていた。これにより、起動時に意図せず`handle_room_change_for_all_tabs`が呼び出され、UIの状態が不安定になることで警告が発生していた。
    2.  **亡霊B「司令塔の非対称性」:** `handle_room_change_for_all_tabs`は**55個**の値を返す司令塔だったが、`handle_delete_room`はUIリセットのために前者を利用しつつ、自身のトリガーをリセットするために追加で**1個**の値を返し、合計**56個**の値を返す非対称な司令塔となっていた。`nexus_ark.py`の`outputs`定義がこの「56個」の仕様に引きずられた結果、55個しか返さない`handle_room_change_for_all_tabs`が呼び出された際に契約違反（`ValueError`）が発生していた。

*   **最終解決アーキテクチャ：「冪等な司令塔」と「統一契約」**
    この二つの亡霊を同時に祓うため、我々は司令塔アーキテクチャをさらに進化させた。
    1.  **冪等性の実装:** `handle_room_change_for_all_tabs`に関数の冒頭で「これから設定しようとしている値が、現在の状態と本当に違うか？」を比較する**ガード節**を設けた。これにより、起動時のように値が変わらない不要な呼び出しを安全にスキップできるようになった。
    2.  **契約の統一:** UIの広範囲な更新を担う全ての司令塔（`handle_room_change...`, `handle_delete_room`）が、常に同じ数（56個）の戻り値を返すように契約を統一した。`handle_room_change...`は、普段は使わない`room_delete_confirmed_state`用のダミー値を末尾に付与することで、この統一契約を遵守する。

*   **教訓:**
    Gradioにおける広範囲なUI更新は、単一のイベントだけでなく、**同じUI群を更新する可能性のある、全てのイベントハンドラ（司令塔）群が一つのチームとして、同じ契約（戻り値の数、型、順番）を共有する**ことによってのみ、その安定性が保証される。そして、各司令塔は、自らが呼び出されるべきでない時に呼び出されても、システムに影響を与えない「冪等性」という名の知性を備えるべきである。

### 教訓12：バックグラウンドの孤独なランナーには、最新の地図（ファイル）を渡せ

*   **問題の核心:**
    アラーム機能のように別スレッドで動作するバックグラウンドプロセスが、アプリ起動時に読み込まれた古いグローバル変数（メモリ上の設定）を参照し続けていたため、UIで設定を変更しても再起動するまで反映されなかった。
*   **解決アーキテクチャ：「JIT (Just-In-Time) コンフィグローディング」**
    バックグラウンドプロセスや、非同期に実行されるツール関数の中では、メモリ上のグローバル変数（`CONFIG_GLOBAL`など）を決して信用してはならない。
    処理を実行する**その瞬間に**、`config_manager.load_config_file()` を呼んでディスク上の `config.json` を読み込み、常に最新の真実に基づいて行動すること。これが、再起動不要な設定変更を実現する唯一の道である。

### 教訓13：入力欄の封印を解け：`interactive=True` の明示

*   **問題の核心:**
    プログラム（`handle_initial_load`）によって値をセットされた `gr.Textbox` が、自動的に読み取り専用モードになり、ユーザーが編集できなくなった。
*   **解決策:**
    初期値を動的に設定するコンポーネントであっても、ユーザーによる編集を許可する場合は、定義時に必ず **`interactive=True`** を明示すること。Gradioの「気を利かせた自動設定」は、時にユーザーの自由を奪う枷となる。

---

### 教訓14：最悪の沈黙、パラメータ・シフトの悲劇（2025-12-20）

*   **問題の核心:**
    新機能追加後、アプリはクラッシュせず正常に動作しているように見えたが、**「特定の設定を保存すると、無関係な設定（AIの声、モデル名、情景描写フラグなど）が、全く別のUIコンポーネントの値で勝手に上書きされる」**という、極めて深刻なサイレント・バグが発生した。

*   **原因：Gradioの非情な「配線順序」仕様**
    Gradioは、UI側のコンポーネント（蛇口）と、バックエンド側の関数の引数（バケツ）を、**「並んでいる順番」だけで紐付けている。**
    1.  UIコンポーネントを1つ追加したが、関数の引数リストの対応する位置への追加を忘れた。
    2.  その結果、それ以降の全ての引数が「1つずつずれて」渡される事態（パラメータ・シフト）が発生した。
    3.  AIの声（`voice_id`）を保存するバケツに、隣のチェックボックスの `True/False` が豪快に注ぎ込まれ、不適切な値で `room_config.json` が上書きされるという事故に至った。

*   **解決アーキテクチャ：「セーフ・マージ」と「一元的保存」**
    この種の「ズレ」が起きたとしても、設定ファイル全体を破壊させないための多層防御を構築した。
    1.  **`room_manager.update_room_config` の全権委任**: ハンドラが直接ディクショナリを構築して保存するのを禁止し、中央の管理関数に「更新したい差分」のみを渡す方式に統一。
    2.  **Load-Merge-Saveパターンの徹底**: 保存時に必ず「既存の設定を読み込み、変更分だけを上書き（マージ）し、それ以外を保持する」ロジックを強制。これにより、たとえ `voice_id` がズレて誤送されても、他の設定項目まで巻き添えで消えることはなくなった。
    3.  **戻り値の数の厳密な定数化**: 司令塔（`handle_initial_load` 等）の返す値の数を厳密に定義（123/152/143）し、1つでもズレれば即座にエラーが出るようにすることで、サイレントな破壊を早期発見可能にした。

*   **教訓:**
    UIの拡張は、単なる部品の追加ではない。それは**「神経系の全ての配線が1ミリも狂わずに繋がっていること」**を保証する、極めて精密な作業である。変更後は、たとえエラーが出なくても、保存されたファイルの中身を直接確認するまでは勝利を疑え。そして、万が一の配線ミスに備え、常に「既存の記憶を尊重するマージの心」をコードに宿せ。

---

### 教訓15：自動実行の暴走を止めろ：値の比較による「冪等（べきとう）な保存」

*   **問題の核心 (2025-12-21):**
    Gradioの `demo.load` や `radio.change` 等で、プログラムから UI に値をセットした際、それが「ユーザー操作」と区別されずにイベントが連鎖し、不要な保存処理と `gr.Info` 通知が大量に発生する「通知スパム」に直面した。

*   **解決アーキテクチャ：「冪等な保存ロジック」**
    イベントハンドラの中で盲目的に保存・通知を行うのではなく、保存関数（`room_manager.update_room_config` 等）の内部で、**「現在の値と、新しく渡された値が本当に異なっているか」** を比較する。
    1.  **不変なら静かに引き返す**: 値が同じであれば、ファイル保存もバックアップ作成も通知も行わず、即座に応答を返す。
    2.  **変化した時のみ声をあげる**: 実際に値が変更された場合のみ `gr.Info` を表示し、永続化を実行する。
    
*   **教訓:**
    Gradioのイベント連鎖は止めることが難しい。システムを守るためには、ロジックの末端（保存・通知関数）に「変更がなければ何もしない」という知性を与えることが、最も確実な防御策である。

---

### 教訓16：AIの「古い知識」を、最新の「ファイル」で上書きし続けろ

*   **問題の核心 (2025-12-21):**
    AI（Antigravity等）が過去の学習データに基づいて、既に廃止された古いモデル名（Gemini 1.5, 2.0等）を良かれと思ってコードに記述したり、設定ファイルに書き込んでしまう「知識のカットオフ問題」が発生した。これにより、一度削除したはずの旧モデル名が `config.json` を介して何度もゾンビのように復活した。

*   **解決アーキテクチャ：「厳格なマージと注釈優先主義」**
    外部設定ファイル (`config.json`) と、プログラム内のデフォルト定義 (`config_manager.py`) をマージする際、**デフォルト定義を絶対的な「真実の源泉」として扱う。**
    1.  **注釈なしモデルの強制排除**: `gemini-3-flash-preview`（注釈なし）が `config.json` にあっても、デフォルトに `(Slow Response)` 付きの名前がある場合は、古い方を問答無用で破棄する。
    2.  **旧世代のキーワード排除**: `gemini-1.5` や `gemini-2.0` といったキーワードを含むモデル名は、たとえユーザー設定ファイルにあっても、デフォルトリストに含まれない限り読み込み時に排除する。

*   **教訓:**
    AI agent と協業する際、AIの内部知識は常に最新ではないことを前提にしなければならない。重要なリスト（利用可能モデル等）の管理においては、プログラム内の静的な定義を「守護者」とし、設定ファイルを動的にクリーンアップし続ける仕組みが不可欠である。

---

### 教訓17：LangGraphのストリームは「途中経過」を自ら記録せよ（2025-12-21）

*   **問題の核心:**
    `agent_node`が正しいモデル名を返しているにも関わらず、UI側で取得する`final_state`には古いモデル名が残るという不可解な現象が発生。ターミナルでは`gemini-3-flash-preview`、タイムスタンプでは`gemini-2.5-`と表示食い違い。

*   **原因：LangGraphのストリーム仕様**
    `app.stream()`は各ノード実行後に`values`モードのペイロードを発行する。最終的な`final_state`は、**最後に実行されたノード**の返り値で状態が更新される。`agent_node`が`model_name`を返しても、その後に実行される`safe_tool_node`等が`model_name`を返さない場合、状態は更新されず初期値のままとなる。

*   **解決アーキテクチャ：「途中経過のキャプチャ」**
    ストリーム処理中に、各`values`ペイロードから必要な値を都度キャプチャして別変数に保持する。
    ```python
    captured_model_name = None
    for mode, chunk in app.stream(initial_state):
        if mode == "values" and chunk.get("model_name"):
            captured_model_name = chunk.get("model_name")  # 途中経過を記録
    # 後続処理では captured_model_name を優先使用
    ```

*   **教訓:**
    LangGraphのような複数ノードを持つグラフにおいて、最終状態だけを信頼してはならない。途中のノードが返した重要な値は、ストリーム処理中に能動的にキャプチャする必要がある。

---

### 教訓18：デフォルト値は唯一の泉から汲め（2025-12-24）

*   **問題の核心:**
    新規ルーム作成時のデフォルト設定を変更するタスクにおいて、`constants.py`の値を変更しても、UIには反映されないという症状が発生。調査の結果、同じデフォルト値が**複数の場所**にハードコードされていた。
    - `constants.py`: `DEFAULT_API_HISTORY_LIMIT_OPTION = "all"`
    - `config_manager.py`: `"api_history_limit": "all"`
    - `ui_handlers.py`: `gr.update(value="全ログ")` (3箇所)
    
    これにより、1箇所を変更しても他の箇所が古い値を返し続け、「変わったはずなのに変わらない」という不可解な状態が生まれた。

*   **解決アーキテクチャ：「Single Source of Truth (唯一の真実の源泉)」**
    デフォルト値は、アプリケーション全体で**ただ一つの場所（`constants.py`）にのみ定義**されるべきである。
    1.  **定数を `constants.py` に集約**: `DEFAULT_API_HISTORY_LIMIT_OPTION = "20"` のように、意味を持つ定数を一箇所で定義。
    2.  **他のファイルは定数を参照**: 
        ```python
        # config_manager.py
        "api_history_limit": constants.DEFAULT_API_HISTORY_LIMIT_OPTION
        
        # ui_handlers.py
        gr.update(value=constants.API_HISTORY_LIMIT_OPTIONS.get(
            constants.DEFAULT_API_HISTORY_LIMIT_OPTION, "20往復"))
        ```
    3.  **ハードコードの禁止**: 文字列リテラル（`"all"`, `"全ログ"`）を直接書くことは、将来の保守性を著しく損なう。

*   **検出方法:**
    grepで疑わしい文字列を検索する。
    ```bash
    grep -rn "全ログ" --include="*.py"
    grep -rn '"all"' --include="*.py" | grep -i history
    ```

*   **教訓:**
    デフォルト値は「一度設定すれば終わり」ではなく、将来変更される可能性のある**設定パラメータ**である。**パラメータは定数化し、定数は一箇所に集約し、全てのコードはその唯一の泉から水を汲む。** これこそが、変更に強く、保守しやすいコードの基本原則である。

---

### 教訓27：Stateをトリガーにするなら、inputsにも必ず含めよ (2025-12-25)

*   **現象**: ルーム削除時に、ユーザーが選択したルームとは**別のルーム**が削除ターゲットになった。

*   **真因**: `room_delete_confirmed_state.change` イベントで `handle_delete_room` を呼び出していたが、**トリガーとなった `room_delete_confirmed_state` 自体がinputsに含まれていなかった**。
    ```python
    # 誤
    inputs=[manage_folder_name_display, api_key_dropdown, current_room_name, ...]
    def handle_delete_room(folder_name, confirmed, api_key, ...):  # ズレる！
    
    # 正
    inputs=[room_delete_confirmed_state, manage_folder_name_display, api_key_dropdown, ...]
    def handle_delete_room(confirmed, folder_name, api_key, ...):  # 一致！
    ```

*   **戒律（解決策）**:
    `.change` イベントのトリガーとなる State は、**必ず inputs の先頭に含め**、関数シグネチャの第1引数と一致させること。

---

### 教訓28：削除は「ゴミ箱移動」を基本とせよ (2025-12-25)

*   **現象**: ルーム削除バグにより、誤って大切なルームのファイルが完全削除された。

*   **真因**: `shutil.rmtree()` は即座にファイルを完全削除するため、復元手段がなかった。

*   **戒律（解決策）**:
    ユーザーデータの削除には **`send2trash`** ライブラリを使用し、Windowsゴミ箱に移動させること。
    ```python
    from send2trash import send2trash
    send2trash(room_path)  # 復元可能！
    ```
    また、重要なデータは **Git でローカルバックアップ** を取り、定期的に自動コミットするスクリプトを用意すること。

---

### 教訓29：`room_config.json` の二重構造を常に意識せよ (2025-12-29)

*   **現象**: 睡眠時記憶整理で更新したはずの「最終更新日」がUIに反映されず、古い日付のままになっていた。

*   **真因**: `room_config.json` は二重構造を持っている。
    - **ルートレベル**: 基本情報 (`room_name`, `description` など) と一部の状態
    - **`override_settings` 内**: ルーム固有の設定 (モデル名、各種フラグなど)
    
    `room_manager.update_room_config()` は**ほぼ全てのキーを `override_settings` 内に保存**する設計だが、古いコードの一部は**ルートレベルに直接保存**したり、**ルートレベルからのみ読み込んだり**していた。この不整合により、保存場所と読み込み場所が一致せず、データが「見えない」状態になっていた。

*   **解決アーキテクチャ：「フォールバック付き読み込み」**
    読み込み時は `override_settings` を優先し、なければルートレベルを確認する。
    ```python
    override_settings = room_config.get("override_settings", {})
    last_update = override_settings.get("last_episodic_update") or room_config.get("last_episodic_update", "未実行")
    ```

*   **教訓:**
    設定ファイルの構造を変更する際は、**保存と読み込みの両方を同時に見直すこと**。古いコードが直接ファイル操作している箇所がないか、必ず grep で確認する。また、中央集権的な保存関数（`update_room_config`）を使うよう統一することが望ましい。

---

### レッスン39: 通知スパム（Redundant Notifications）の防御（2025-12-29）

#### 問題の症状
アプリ起動時やルーム切り替え時に、設定が変わっていない（前回と同じ）にもかかわらず、「○○モードに変更しました」といった通知がいちいち表示され、ユーザー体験を損なっていた。

#### 根本原因
UIコンポーネントの初期化やルーム変更に伴う「プログラムによる値の書き換え」が、ハンドラの `.change()` イベント等をトリガーしてしまい、ハンドラ側で「値が以前と同じかどうか」のチェック（冪等性チェック）を行わずに通知を出していたため。

#### 解決策：ハンドラ内での「比較ガード」
1. **現在値の取得**: ハンドラ関数の冒頭で、現在の設定ファイルや `State` から、その項目の現在の値を取得する。
2. **比較 & 早期リターン**: UIから渡された「新しい値」が「現在の値」と同じであれば、通知（`gr.Info` 等）と保存処理をスキップして即座にリターンする。

```python
# ui_handlers.py
def handle_something_change(room_name: str, new_mode: str):
    # 1. 現在の設定を取得
    effective_settings = config_manager.get_effective_settings(room_name)
    current_mode = effective_settings.get("some_mode")

    # 2. 変更がある場合のみ、副作用（保存・通知）を実行
    if new_mode != current_mode:
        save_logic(new_mode)
        gr.Info(f"モードを「{new_mode}」に変更しました。")
    
    # UIの表示状態自体は常に最新に保つために更新を返す
    return gr.update(...)
```

#### 教訓
**「イベントが発火した ＝ ユーザーが意図的に変更した」とは限らない。** 
特に複雑なUI連鎖がある場合、ハンドラは常に「本当に変更があったのか？」を疑い、無駄な通知を出さないように自衛しなければならない。これはレッスン14やレッスン36の思想をさらに汎用化したものである。

---

### レッスン40: 「お出かけ」用AI要約と動的ログ加工の黄金律（2025-12-29）

#### 1. AI要約プロンプトの「純粋化」
- **問題**: AIに要約を頼むと、「はい、承知しました。要約を開始します」といった説明的な応答が混入し、エクスポートデータのノイズになる。
- **解決策**: プロンプト内に【制約事項】として**「出力には圧縮後のテキストのみを含めること」「前置き、説明、挨拶は一切不要」**と厳格に明示する。これにより、後工程でのパースを不要にし、そのまま貼れるクリーンなデータを得られる。

#### 2. 表示オプションによる動的なログ加工
- **問題**: ログの中からタイムスタンプやモデル名を除きたいという要望に対し、物理ファイルを書き換えるのはリスクが高すぎる。
- **解決策**: UI側に「タイムスタンプを含む」「モデル名を含む」等のチェックボックス（`gr.Checkbox`）を用意し、**読み込み時（表示時）にオンメモリで正規表現を使って加工**する。
- **実装のコツ**: 
  - 加工されたテキストを返す関数（例: `_get_recent_log_entries`）に、これらのフラグを引数として渡す。
  - チェックボックスが変更された際にも `.change()` イベントでその関数を再実行（リロード）することで、ユーザーに即時フィードバックを提供する。

#### 3. APIキー取得の「標準パス」
- **問題**: 新機能でAI（LLM）を使いたい時、どこからAPIキーを持ってくるべきか混乱する。
- **解決策**: `config_manager.initial_api_key_name_global` (現在のUIで選択されているキー名) と `config_manager.GEMINI_API_KEYS` (キー名と値の対応表) を組み合わせるのが「Nexus Arkの標準」である。
  ```python
  api_key_name = config_manager.initial_api_key_name_global
  api_key = config_manager.GEMINI_API_KEYS.get(api_key_name)
  ```
  この一貫性を守ることで、ユーザーが設定したAPIキー設定が常に全ての機能で尊重される。

---

### 教訓41：Windows環境でのファイルロック回避：リネーム退避と非同期クリーンアップの作法 (2025-12-31)

*   **問題の核心:**
    FAISSインデックスなどのディレクトリを上書き保存しようとする際、Windows環境で `PermissionError: [WinError 5] アクセスが拒否されました` が頻発した。リトライ処理や `gc.collect()` によるメモリ解放を試みても、ウイルス対策ソフトやOSのインデックスサービス、あるいは内部ルーチンがハンドルを握り続けている場合、削除 (`shutil.rmtree`) は失敗し、システムが停止してしまう。

*   **解決アーキテクチャ：「リネーム退避方式 (Rename-before-Delete)」**
    Windowsでは「使用中のファイルの削除」は厳しく制限されているが、「使用中のファイルの**リネーム（名前変更）**」は、同じドライブ内であれば成功することが多いという特性を利用する。

    1.  **リネームによる道明け**: 既存のディレクトリ（例: `faiss_index`）を削除しようとせず、まず `faiss_index.old_timestamp` のような一時的な名前にリネームして、本来のパスを空ける。
    2.  **新規配置**: 空いた本来のパスに、新しいデータを配置する。
    3.  **非同期（後回し）クリーンアップ**: 退避させた `.old` ディレクトリの削除を試みる。もしロックが残っていて失敗しても、**エラーを無視（パス）**し、処理自体は成功として続行する。古いフォルダは次回の更新時や、OSの再起動タイミングなどで削除されれば良しとする。

*   **教訓:**
    Windowsにおけるファイルロック問題は、真正面から「解除を待つ」のではなく、**「別名に変えて脇にどける」**ことで、ロックを保持したままパスを解放させるのが最も確実な回避策である。また、重要なデータ更新において、不要になった古いデータの削除（お掃除）の成否を、メイン処理の成功条件に含めない（疎結合にする）柔軟な設計が、システムの堅牢性を高める。

---

### 教訓42：Gradioの初期化イベントと.changeイベントの発火順序は信用できない (2026-01-03)

*   **問題の核心:**
    起動時に「個別設定を保存しました」という通知が表示されてしまう。ユーザーが変更を加えた時のみ表示すべきなのに、UI初期化時にも通知が出る。

*   **調査で判明した真因:**
    1. **`.change`イベントは値の変更原因を区別しない**: Gradioの`.change`イベントは「ユーザー操作」と「プログラムによる値設定」を区別できない
    2. **イベントの発火順序が非決定的**: `demo.load`（初期化）と`.change`イベントは並列・非同期で動き、順序が保証されない
    3. **初期化完了後もイベントが遅延発火**: `handle_initial_load`が完了した**後**にも、Gradioが遅延で`.change`イベントを発火させる

*   **失敗した解決策:**
    1. **grace period方式（起動後5秒間は抑制）**: モジュールインポート時に開始すると、アプリ起動完了までに5秒経過してしまう
    2. **handle_initial_loadで起動時刻リセット**: `.change`イベントとの並列実行で、リセット前にイベント発火
    3. **初期化完了フラグ方式のみ**: 初期化完了後の遅延イベントを防げない

*   **成功した解決策：ハイブリッド方式**
    ```python
    # グローバル変数
    _initialization_completed = False
    _initialization_completed_time = 0
    POST_INIT_GRACE_PERIOD_SECONDS = 3

    # handle_initial_load の開始時
    _initialization_completed = False

    # handle_initial_load の完了時
    _initialization_completed = True
    _initialization_completed_time = time.time()

    # 通知ロジック
    if not _initialization_completed:
        pass  # 初期化中は通知しない
    elif (now - _initialization_completed_time) < POST_INIT_GRACE_PERIOD_SECONDS:
        pass  # 初期化完了直後のgrace period中は通知しない
    else:
        gr.Info(...)  # 通常通り通知
    ```

*   **教訓:**
    Gradioのイベントモデルは「すべてが非同期で動く」という前提で設計する必要がある。初期化処理と`.change`イベントは**競合状態（Race Condition）**にあると考え、タイミングに依存しない堅牢な抑制ロジック（フラグ + 時間ベースの二重ガード）を設計すること。

    また、Gradio 4.x以降の`trigger_mode="user"`オプションは理論上ユーザー操作のみでイベント発火させられるが、すべてのコンポーネントで完全にサポートされているわけではなく、挙動が不安定な場合もある。現時点では「泥臭い」ハイブリッド方式が最も確実。

---

## 教訓 15: バックグラウンドスレッドの長時間処理に対するタイムアウト保護 (2026-01-04)

*   **発生した問題:**
    睡眠時記憶整理処理（特に現行ログ索引更新）が長時間ブロックされると、同じスレッド上で実行される自律行動チェックが一切実行されなくなった。

*   **原因:**
    スケジューラスレッドは単一スレッドで、`schedule.run_pending()` 内で時間のかかる処理がブロックすると、後続のジョブ（自律行動チェック）が実行されない。ジェネレーター消費処理（`for ... in generator`）が無限ループに近い状態になると、例外がキャッチされずスレッドが止まる。

*   **解決策:**
    `ThreadPoolExecutor` を使用して、処理を別スレッドで実行し、タイムアウト（10分）を設定。タイムアウト時は警告ログを出力して次の処理に進む。

    ```python
    from concurrent.futures import ThreadPoolExecutor, TimeoutError as FuturesTimeoutError

    def run_long_task():
        # 長時間かかる可能性のある処理
        pass

    with ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(run_long_task)
        try:
            result = future.result(timeout=600)  # 10分
        except FuturesTimeoutError:
            print("処理がタイムアウトしました。次回に再試行します。")
    ```

*   **教訓:**
    バックグラウンドのスケジューラスレッドで実行される処理は、**必ずタイムアウト機構を設ける**こと。特にジェネレーター消費や外部API呼び出しなど、完了時間が予測できない処理は危険。スレッド全体がブロックされると、アプリケーションの他の重要な機能（アラーム、自律行動など）が停止する可能性がある。

