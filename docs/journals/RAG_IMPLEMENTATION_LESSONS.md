# RAG実装の道：14回の失敗から学んだ、SDKとの対話術

## はじめに

このドキュメントは、Nexus ArkにRAG（Retrieval-Augmented Generation）機能を実装する過程で、我々が直面した14回にもわたる壮絶な戦いの記録である。これは単なる失敗の歴史ではない。GoogleのSDK、外部ライブラリ、そして自分自身の思い込みと、いかに対話し、真実へと至るかの、実践的な航海日誌である。

## 我々が乗り越えた7つの「絶望の壁」

### 壁1：API呼び出しの「作法」 - `Client`オブジェクトこそが唯一の窓口である

-   **問題:** `genai.embed_content()` や `genai.configure()` を直接呼び出そうとして、幾度となく `AttributeError` の前に砕け散った。
-   **教訓:** このプロジェクトの聖典 `AI_DEVELOPMENT_GUIDELINES.md` に書かれている通り、`_gemini_client = genai.Client(...)` で作成した**クライアントオブジェクトが、全てのAPIとの唯一の通信窓口**である。チャットの `generate_content` も、埋め込みの `embed_content` も、必ず `_gemini_client.models` という部門を通して依頼しなければならない。この作法を破ることは、決して許されない。
    -   **正:** `gemini_api._gemini_client.models.embed_content(...)`
    -   **誤:** `genai.embed_content(...)`
    -   **誤:** `gemini_api._gemini_client.embed_content(...)`

### 壁2：引数の「単数形と複数形」 - たった一文字が世界を分ける

-   **問題:** `content` や `embedding` という引数名/属性名を使い続け、`TypeError` と `AttributeError` の無限ループに陥った。
-   **教訓:** エラーメッセージは、最高の教師である。「Did you mean: 'contents'?」「Did you mean: 'embeddings'?」というPythonからの問いかけは、神の啓示に等しい。APIが要求する引数名や属性名は、**複数形か単数形か、その一文字に至るまで、完全に正確でなければならない。** 思い込みを捨て、エラーメッセージを謙虚に読め。
    -   **正:** `contents=`
    -   **正:** `result.embeddings`

### 壁3：`task_type`引数の「罠」 - 同じ名前でも、作法が違えば意味も違う

-   **問題:** `task_type` 引数を指定したことで、`TypeError` が発生した。
-   **教訓:** `google-genai` SDKには、同じ `embed_content` という名前でも、**全く異なる2つの作法が存在する**ことを知った。
    1.  **グローバル関数形式 (`genai.embed_content`)**: こちらは `task_type` 引数を持つ。
    2.  **クライアント経由形式 (`client.models.embed_content`)**: こちらは `task_type` 引数を持たない。
    我々のプロジェクトは後者を採用しているため、`task_type` を指定することは、作法違反であった。

### 壁4：APIの「利用制限」 - 一度に運べる荷物には限りがある

-   **問題:** 193個のチャンクを一度にAPIに投げ、`400 INVALID_ARGUMENT` エラー（バッチ上限は100）で弾かれた。
-   **教訓:** APIは、無限のパワーを持つ魔法の箱ではない。それは、明確な利用制限を持つ、現実のサービスである。大量のデータを扱う際は、必ず公式ドキュメントで**バッチサイズの上限を確認し、データを分割してループ処理する**という、基本的な作法を徹底しなければならない。

### 壁5：APIレスポンスの「構造」 - データは専用の小箱に入って届く

-   **問題:** APIから返ってきた `EmbedContentResponse` オブジェクトを、リストや辞書のように扱おうとして、`TypeError` や `AttributeError` を連発した。
-   **教訓:** APIからの返り値は、常にその構造を `print()` やデバッガで確認し、敬意を払うべきである。今回の `result.embeddings` は、「`ContentEmbedding`オブジェクトのリスト」であった。そして、実際のベクトル値は、そのオブジェクトの `.values` という属性に格納されていた。
    -   **正:** `dimension = len(all_embeddings[0].values)`
    -   **正:** `vectors_to_add = np.array([emb.values for emb in all_embeddings], ...)`

### 壁6：FAISSとWindowsの「相性」 - 日本語ファイルパスという見えざる壁

-   **問題:** 全てのコードが完璧に見えても、FAISSライブラリが日本語の文字を含むファイルパスへの**書き込み (`save_local`)** および **読み込み (`load_local`)** に失敗し、`RuntimeError` や `could not open ... for reading` といった致命的なエラーが発生した。
-   **教訓:** エラーの原因は、自分のコードの中だけにあるとは限らない。時には、**使用しているライブラリ（特にC++ベースのライブラリ）と、OSの組み合わせに起因する、根深い問題**が存在する。この「見えざる壁」と正面から戦ってはならない。我々がすべきことは、**ライブラリを、その問題が存在しない「安全地帯」で動作させる**ことである。
    -   **書き込み時 (`handle_knowledge_reindex`):** `tempfile`を使い、まず**英数字のパスを持つ一時ディレクトリ**に索引を書き込ませる。その後、Pythonの`shutil.move`を使って、完成した索引ファイルを本来の日本語パスの場所へ移動させる。
    -   **読み込み時 (`search_knowledge_base`):** `tempfile`と`shutil.copytree`を使い、まず**日本語パスにある索引フォルダ全体を、英数字の一時ディレクトリ**に丸ごとコピーする。そして、FAISSにはそのコピー先のパスを渡して読み込ませる。処理が終われば、一時ディレクトリは自動的に消去される。
    この**「聖域化（Sanctuary）」パターン**こそが、ライブラリの内部実装に手を加えることなく、外部環境に起因する問題をエレガントに回避するための、唯一の正解である。

### 壁7：コピー＆ペーストの「悪魔」 - 最後の最後に潜む、単純な構文エラー

-   **問題:** 修正を重ねるうちに、依頼書作成時のマークダウン記法（```）などがコードに混入し、`SyntaxError` で起動すらできなくなった。
-   **教訓:** 長い戦いの後こそ、心に隙が生まれる。コードをファイルに書き込む際は、どんなに単純な修正でも、**全体を、冷静に、そして、謙虚に見直すこと。** 最も単純なミスが、最も大きな時間の浪費に繋がる。

## まとめ

RAGの実装は、単にコードを書く作業ではなかった。それは、SDKの設計思想を深く理解し、エラーメッセージと真摯に対話し、ライブラリの癖を読み解き、そして、自分自身の思い込みと戦い続ける、長く、しかし、実り多き「対話」の旅であった。この記録が、未来の我々の助けとなることを、ここに記す。
