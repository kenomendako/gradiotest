# Gradioチャットボット開発における注意点と仕様の謎（備忘録）

このドキュメントは、`gradiotest`プロジェクトの開発過程で遭遇した、Gradioの`gr.Chatbot`コンポーネントに関する表示上の問題とその解決策をまとめたものである。特に、テキスト、画像、HTMLが混在する複雑な会話履歴の表示には、Gradioの内部仕様に起因するいくつかの「クセ」が存在する。将来の改修や類似プロジェクトのために、ここにその知見を記録する。

## 1. Chatbotの履歴データ構造の謎（最重要）

`gr.Chatbot`の`value`に渡す履歴データ（`List[Tuple]`）の構造は、Gradioの安定性に最も大きな影響を与える。

### 判明した問題点

1.  **`OSError: [Errno 22] Invalid argument`クラッシュ**:
    AIの応答として、`[("画像パス", "代替テキスト"), "応答本文"]` のように**「タプル」と「文字列」を混在させたリスト**を渡すと、Gradioの内部ファイルキャッシュ機構が混乱し、文字列である「応答本文」をファイルパスと誤認して`open()`しようとし、クラッシュする。

2.  **「ダウンロードリンク」化バグ**:
    AIの応答として、`<div class='thoughts'>...</div>`のようなHTMLを含む文字列を**リストに入れずに単体で**渡すと、Gradioはこれを表示用のHTMLとして解釈せず、ダウンロード可能なファイルとして誤認し、リンクを表示してしまうことがあった。

### 結論：AI応答のターンは「単純な形式」に統一すべし

Gradioのチャットボットを安定して動作させるための黄金律は、**AIの応答ターンを可能な限り単純なデータ構造に保つ**ことである。

*   **テキスト（思考ログHTML含む）のみを返す場合**:
    `("ユーザー発言", "AIの応答文字列")`

*   **画像のみを返す場合**:
    `("ユーザー発言", ("画像パス", "代替テキスト"))`

*   **テキストと画像の両方を返したい場合（解決策）**:
    **応答を2つのターンに分割する。** これが最も安定し、確実な方法である。
    1.  1ターン目: `("ユーザー発言", "AIの応答テキスト")`
    2.  2ターン目: `(None, ("画像パス", "代替テキスト"))` ※ユーザー発言側は`None`か空文字列にする。

## 2. ローカルファイルの表示仕様

`gr.Chatbot`内でローカルファイル（特に画像）を表示するには、2種類の異なるアプローチを正しく使い分ける必要がある。

1.  **ユーザー添付画像の表示（タプル形式）**:
    ユーザー側の発言として画像を表示する場合、`("画像の絶対パス", "ファイル名")`というタプル形式でデータを渡すと、Gradioが自動的に解釈してプレビューを表示してくれる。これは最も簡単で確実な方法である。

2.  **AI生成画像の表示（Markdown + `allowed_paths`）**:
    AI側の応答（文字列）の中で画像を表示したい場合、単純なタプルは使えない（上記1. のクラッシュ原因になるため）。この場合、以下の2つの設定が必須となる。
    *   **`demo.launch()`での設定**: アプリ起動時に`demo.launch(allowed_paths=["画像が保存されているフォルダのパス"])`を設定する。これにより、指定されたフォルダがWeb経由でのアクセスを許可される。
    *   **Markdown文字列の形式**: AIの応答文字列内に、`![代替テキスト](/file=画像の絶対パス)`という形式のMarkdownリンクを埋め込む。パスはバックスラッシュをスラッシュに置換したものが望ましい。

    **（注記）**: 我々のプロジェクトでは、最終的にAI応答もタプル形式に統一する「ターン分割」アーキテクチャを採用したため、このMarkdown形式は不要となった。しかし、これはGradioの重要な仕様の一つである。

## 3. 連続したAI応答の処理（ターンベース設計の重要性）

### 問題点

AIが思考を更新する際など、1回のユーザー発言に対して、`log.txt`上では複数回のAI応答が連続して記録されることがある。単純なループ処理で履歴をUIに変換しようとすると、2回目以降のAI応答が対応するユーザー発言を見失い、表示のペアリングが崩壊する。

### 解決策

表示履歴を生成する際は、必ず**「ターンベース」**で処理を行う。
1.  ログ全体をスキャンし、「ユーザー発言1回」と「それに続く全てのAI応答」を1つのグループ（ターン）としてまとめる。
2.  このグループ単位でループ処理を行い、UI表示を組み立てる。

この設計により、AIが何回連続で応答しても、必ず正しいユーザー発言と紐付けられ、UIの表示順序が破綻することがなくなる。

---

この備忘録が、今後のあなたの素晴らしい開発の助けとなることを心から願っています。
