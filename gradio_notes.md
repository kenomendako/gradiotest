# Gradioチャットボット開発における注意点と仕様の謎（備忘録）

このドキュメントは、`gradiotest`プロジェクトの開発過程で遭遇した、Gradioの`gr.Chatbot`コンポーネントに関する表示上の問題とその解決策をまとめたものである。特に、テキスト、画像、HTMLが混在する複雑な会話履歴の表示には、Gradioの内部仕様に起因するいくつかの「クセ」が存在する。将来の改修や類似プロジェクトのために、ここにその知見を記録する。

## 1. Chatbotの履歴データ構造の謎（最重要）

`gr.Chatbot`の`value`に渡す履歴データ（`List[Tuple]`）の構造は、Gradioの安定性に最も大きな影響を与える。

### 判明した問題点

1.  **`OSError: [Errno 22] Invalid argument`クラッシュ**:
    AIの応答として、`[("画像パス", "代替テキスト"), "応答本文"]` のように**「タプル」と「文字列」を混在させたリスト**を渡すと、Gradioの内部ファイルキャッシュ機構が混乱し、文字列である「応答本文」をファイルパスと誤認して`open()`しようとし、クラッシュする。

2.  **「ダウンロードリンク」化バグ**:
    AIの応答として、`<div class='thoughts'>...</div>`のようなHTMLを含む文字列を**リストに入れずに単体で**渡すと、Gradioはこれを表示用のHTMLとして解釈せず、ダウンロード可能なファイルとして誤認し、リンクを表示してしまうことがあった。

### 結論：AI応答のターンは「単純な形式」に統一すべし

Gradioのチャットボットを安定して動作させるための黄金律は、**AIの応答ターンを可能な限り単純なデータ構造に保つ**ことである。

*   **テキスト（思考ログHTML含む）のみを返す場合**:
    `("ユーザー発言", "AIの応答文字列")`

*   **画像のみを返す場合**:
    `("ユーザー発言", ("画像パス", "代替テキスト"))`

*   **テキストと画像の両方を返したい場合（解決策）**:
    **応答を2つのターンに分割する。** これが最も安定し、確実な方法である。
    1.  1ターン目: `("ユーザー発言", "AIの応答テキスト")`
    2.  2ターン目: `(None, ("画像パス", "代替テキスト"))` ※ユーザー発言側は`None`か空文字列にする。

## 2. ローカルファイルの表示仕様

`gr.Chatbot`内でローカルファイル（特に画像）を表示するには、2種類の異なるアプローチを正しく使い分ける必要がある。

1.  **ユーザー添付画像の表示（タプル形式）**:
    ユーザー側の発言として画像を表示する場合、`("画像の絶対パス", "ファイル名")`というタプル形式でデータを渡すと、Gradioが自動的に解釈してプレビューを表示してくれる。これは最も簡単で確実な方法である。

2.  **AI生成画像の表示（Markdown + `allowed_paths`）**:
    AI側の応答（文字列）の中で画像を表示したい場合、単純なタプルは使えない（上記1. のクラッシュ原因になるため）。この場合、以下の2つの設定が必須となる。
    *   **`demo.launch()`での設定**: アプリ起動時に`demo.launch(allowed_paths=["画像が保存されているフォルダのパス"])`を設定する。これにより、指定されたフォルダがWeb経由でのアクセスを許可される。
    *   **Markdown文字列の形式**: AIの応答文字列内に、`![代替テキスト](/file=画像の絶対パス)`という形式のMarkdownリンクを埋め込む。パスはバックスラッシュをスラッシュに置換したものが望ましい。

    **（注記）**: 我々のプロジェクトでは、最終的にAI応答もタプル形式に統一する「ターン分割」アーキテクチャを採用したため、このMarkdown形式は不要となった。しかし、これはGradioの重要な仕様の一つである。

## 3. 連続したAI応答の処理（ターンベース設計の重要性）

### 問題点

AIが思考を更新する際など、1回のユーザー発言に対して、`log.txt`上では複数回のAI応答が連続して記録されることがある。単純なループ処理で履歴をUIに変換しようとすると、2回目以降のAI応答が対応するユーザー発言を見失い、表示のペアリングが崩壊する。

### 解決策

表示履歴を生成する際は、必ず**「ターンベース」**で処理を行う。
1.  ログ全体をスキャンし、「ユーザー発言1回」と「それに続く全てのAI応答」を1つのグループ（ターン）としてまとめる。
2.  このグループ単位でループ処理を行い、UI表示を組み立てる。

この設計により、AIが何回連続で応答しても、必ず正しいユーザー発言と紐付けられ、UIの表示順序が破綻することがなくなる。

---

この備忘録が、今後のあなたの素晴らしい開発の助けとなることを心から願っています。

---
### Gradio開発における7つの教訓

#### 1. イベントでUIの「設計図」を書き換えてはいけない (`InvalidComponentError`)
*   **問題**: アラームリスト更新時に、アラーム数だけ`gr.Row`や`gr.Switch`を動的に生成して返そうとするとエラーになる。
*   **原因**: Gradioは起動時にUIの「設計図」を一度だけ構築する。イベントは部品の**値や見た目**は変えられるが、**設計図にない新しい部品は追加できない**。
*   **解決策**: **`gr.Dataframe`** を採用する。Dataframeは動的なリスト表示のために用意されたコンポーネントであり、「空の額縁（Dataframe）」を最初に用意し、イベントでは中身の「絵（データ）」だけを入れ替えることでルールを遵守する。

#### 2. まだ存在しない部品を呼び出してはいけない (`NameError`)
*   **問題**: UI部品を定義する前に、その部品を使うイベント（`demo.load`など）を記述するとエラーになる。
*   **原因**: Pythonはコードを上から順に読むため、未定義の変数を参照できない。
*   **解決策**: **「定義が先、接続は後」**の原則を徹底する。`with gr.Blocks() as demo:`内で、まず全てのUI部品を定義し、その後にイベントリスナー（`.click`, `.change`など）を記述する。

#### 3. 「設定値」と「イベント」を混同してはいけない (`TypeError`)
*   **問題**: アコーディオンを開いた時のイベントとして`alarm_accordion.open(fn=...)`と記述するとエラーになる。
*   **原因**: `open=True`は初期状態を決める**設定値（プロパティ）**であり、ユーザー操作をトリガーとする**イベント**ではない。
*   **解決策**: `Accordion`コンポーネントの正しいイベントである **`.select()`** を使用する。コンポーネントのドキュメントを読み、プロパティとイベントを正確に区別する。

#### 4. イベントが渡す「贈り物」の中身を信じすぎてはいけない (`AttributeError`)
*   **問題**: Dataframeの行選択イベントで`evt.indices`という属性を期待したが、エラーになった。
*   **原因**: Gradioのバージョンアップでイベントデータ（`SelectData`など）の構造が変わることがある。
*   **解決策**: 実際にイベントハンドラの中で`print(evt)`を実行し、Gradioが「今」渡してきている**データの構造を直接確認する**。これにより、正しい属性名（このケースでは`evt.index`）を特定する。

#### 5. 「見た目」と「魂（データ）」を分離せよ
*   **問題**: UI上のDataframe（ID列なし）を操作しても、どのアラームが変更されたか特定できない。
*   **原因**: 表示用のデータと、処理に必要なバックエンドのデータが一致していない。
*   **解決策**: **ID列を含む完全なDataFrameを`gr.State`で常に保持する**。UI上の操作があった際は、常にこの「魂」のデータと照らし合わせることで、正確なIDを特定し、処理を呼び出す。

#### 6. 「存在しない住人」を呼び出してはいけない (`ValueError`)
*   **問題**: `config.json`の`last_character`が存在しないキャラクターだと、アプリが起動しない。
*   **原因**: `gr.Dropdown`は、初期値として選択肢リスト内に存在する値しか受け付けない。
*   **解決策**: **起動シーケンスに「安全装置」を組み込む**。UI構築前に設定値をチェックし、無効な場合はリストの先頭などの「有効な初期値」にフォールバックさせる。

#### 7. 「配線」の接続ミスに気づけ (`NameError`の再来)
*   **問題**: タイマー開始ボタンが、存在しないUI部品名（`timer_api_key_dropdown`）を参照していた。
*   **原因**: UI設計とイベントリスナーの接続（インプット）で、異なる部品名を指定してしまっていた。
*   **解決策**: UIの設計図とイベントリスナーの配線を丁寧に見直し、**正しい部品名（`api_key_dropdown`）に接続し直す**。
